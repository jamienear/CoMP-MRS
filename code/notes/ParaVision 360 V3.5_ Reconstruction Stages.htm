<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=9">
<meta name="generator" content="Doxygen 1.8.11">
<title>ParaVision 360 V3.5: Reconstruction Stages</title>
<link href="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/tabs.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/jquery.js"></script>
<script type="text/javascript" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/dynsections.js"></script>
<link href="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/resize.js"></script>
<script type="text/javascript" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/navtreedata.js"></script>
<script type="text/javascript" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/searchdata.js"></script>
<script type="text/javascript" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/doxygen.css" rel="stylesheet" type="text/css">
<script id="navtreeindex0" type="text/javascript" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/navtreeindex0.js"></script><script id="index" type="text/javascript" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/index.js"></script><script id="Topics" type="text/javascript" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/Topics.js"></script></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ParaVision 360 V3.5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/modules.html"><span>Modules</span></a></li>
      <li><a href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/close.png" alt=""></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable" style="width: 256px; height: 1429px;">
  <div id="nav-tree" style="height: 1429px;">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="top: 5px;"><img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/sync_on.png" title="click to disable panel synchronisation"></div>
    <ul style="display: block;"><li><div class="item"><a href="javascript:void(0)"><img style="padding-left: 0px;" width="16" height="22" border="0" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/arrowdown.png"></a><span class="label"><a class="index.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/index.html">ParaVision 360 V3.5</a></span></div><ul class="children_ul" style="display: block;"><li><div class="item"><a href="javascript:void(0)"><img style="padding-left: 16px;" width="16" height="22" border="0" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/arrowdown.png"></a><span class="label"><a class="index.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/index.html">Method Programming Interfaces</a></span></div><ul class="children_ul" style="display: block;"><li><div class="item"><a href="javascript:void(0)"><img style="padding-left: 32px;" width="16" height="22" border="0" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/arrowright.png"></a><span class="label"><a class="Modules.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Modules.html">PVM Modules</a></span></div></li><li><div class="item"><a href="javascript:void(0)"><img style="padding-left: 32px;" width="16" height="22" border="0" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/arrowdown.png"></a><span class="label"><a class="Topics.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Topics.html">Topics</a></span></div><ul class="children_ul" style="display: block;"><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Nucleus.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Nucleus.html">Nucleus and Frequency</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="RFPulses.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RFPulses.html">RF Pulses</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Encoding.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Encoding.html">Encoding</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Geometry.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Geometry.html">Geometry</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="GeoObject.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/GeoObject.html">Geometry Object</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Gradients.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Gradients.html">Gradients</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Reconstruction.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Reconstruction.html">Reconstruction Tools</a></span></div></li><li><div class="item"><a href="javascript:void(0)"><img style="padding-left: 48px;" width="16" height="22" border="0" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/arrowdown.png"></a><span class="label"><a class="RecoPublicStages.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html">Reconstruction Stages</a></span></div><ul class="children_ul" style="display: block;"><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:Overview" href="javascript:void(0)">Overview</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:DataDescriptor" href="javascript:void(0)">DataDescriptor</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoAddFilter" href="javascript:void(0)">RecoAddFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoAnalyseFidFilter" href="javascript:void(0)">RecoAnalyseFidFilter</a></span></div></li><li><div class="item selected" id="selected"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoAverageFilter" href="javascript:void(0)">RecoAverageFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoBufferSink" href="javascript:void(0)">RecoBufferSink</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoBufferSource" href="javascript:void(0)">RecoBufferSource</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoCalcTrajectoryFilter" href="javascript:void(0)">RecoCalcTrajectoryFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoCastFilter" href="javascript:void(0)">RecoCastFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoCombineFilter" href="javascript:void(0)">RecoCombineFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoConjQnegFilter" href="javascript:void(0)">RecoConjQnegFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoCorrPhaseFilter" href="javascript:void(0)">RecoCorrPhaseFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoCpmgCorrFilter" href="javascript:void(0)">RecoCpmgCorrFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoCreateMaskFilter" href="javascript:void(0)">RecoCreateMaskFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoAutoCreateMaskFilter" href="javascript:void(0)">RecoAutoCreateMaskFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoCutoffFilter" href="javascript:void(0)">RecoCutoffFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoDetermineB0Filter" href="javascript:void(0)">RecoDetermineB0Filter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoDivideFilter" href="javascript:void(0)">RecoDivideFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoDummySink" href="javascript:void(0)">RecoDummySink</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoDummySource" href="javascript:void(0)">RecoDummySource</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoExpWinMultFilter" href="javascript:void(0)">RecoExpWinMultFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoExtractFilter" href="javascript:void(0)">RecoExtractFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoFidCorrFilter" href="javascript:void(0)">RecoFidCorrFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoFileSink" href="javascript:void(0)">RecoFileSink</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoFileSource" href="javascript:void(0)">RecoFileSource</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoFlowFilter" href="javascript:void(0)">RecoFlowFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoFrqOffsetFilter" href="javascript:void(0)">RecoFrqOffsetFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoFTFilter" href="javascript:void(0)">RecoFTFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoFTShiftFilter" href="javascript:void(0)">RecoFTShiftFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoGaussWinMultFilter" href="javascript:void(0)">RecoGaussWinMultFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoHalfFourierFilter" href="javascript:void(0)">RecoHalfFourierFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoHistogramFilter" href="javascript:void(0)">RecoHistogramFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoInverseFidFilter" href="javascript:void(0)">RecoInverseFidFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoMagnitudeFilter" href="javascript:void(0)">RecoMagnitudeFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoMapFilter" href="javascript:void(0)">RecoMapFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoMaskFilter" href="javascript:void(0)">RecoMaskFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoMeanFilter" href="javascript:void(0)">RecoMeanFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoMethodFilter" href="javascript:void(0)">RecoMethodFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoSystemFilter" href="javascript:void(0)">RecoSystemFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoMinMaxFilter" href="javascript:void(0)">RecoMinMaxFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoMultFilter" href="javascript:void(0)">RecoMultFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoConjMultFilter" href="javascript:void(0)">RecoConjMultFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoParameterSink" href="javascript:void(0)">RecoParameterSink</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoParameterSource" href="javascript:void(0)">RecoParameterSource</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoPCAFilter" href="javascript:void(0)">RecoPCAFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoPhasCorrFilter" href="javascript:void(0)">RecoPhasCorrFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoPhasedAccumFilter" href="javascript:void(0)">RecoPhasedAccumFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoPhaseDiffFilter" href="javascript:void(0)">RecoPhaseDiffFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoPhaseFilter" href="javascript:void(0)">RecoPhaseFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoPhaseWeightingFilter" href="javascript:void(0)">RecoPhaseWeightingFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoPIGrappaCalibFilter" href="javascript:void(0)">RecoPIGrappaCalibFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoPIGrappaRecoFilter" href="javascript:void(0)">RecoPIGrappaRecoFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoPIRefExtractFilter" href="javascript:void(0)">RecoPIRefExtractFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoPrintFilter" href="javascript:void(0)">RecoPrintFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoReformatFilter" href="javascript:void(0)">RecoReformatFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoRegridApodCorrFilter" href="javascript:void(0)">RecoRegridApodCorrFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoRegridDensCorrFilter" href="javascript:void(0)">RecoRegridDensCorrFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoRegridFilter" href="javascript:void(0)">RecoRegridFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoRegridNFilter" href="javascript:void(0)">RecoRegridNFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoReImFilter" href="javascript:void(0)">RecoReImFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoReloadB0Filter" href="javascript:void(0)">RecoReloadB0Filter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoRemoveFilter" href="javascript:void(0)">RecoRemoveFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoReverseFilter" href="javascript:void(0)">RecoReverseFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoRGateApplyOrderFilter" href="javascript:void(0)">RecoRGateApplyOrderFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoRGateDisplayFilter" href="javascript:void(0)">RecoRGateDisplayFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoRGateFindOrderFilter" href="javascript:void(0)">RecoRGateFindOrderFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoScaleFilter" href="javascript:void(0)">RecoScaleFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoShuffleProfilesFilter" href="javascript:void(0)">RecoShuffleProfilesFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoSincWinMultFilter" href="javascript:void(0)">RecoSincWinMultFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoSineWinMultFilter" href="javascript:void(0)">RecoSineWinMultFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoSortFilter" href="javascript:void(0)">RecoSortFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoSpectCorrFilter" href="javascript:void(0)">RecoSpectCorrFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoSplitFilter" href="javascript:void(0)">RecoSplitFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoSquareRootFilter" href="javascript:void(0)">RecoSquareRootFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoSquareWinMultFilter" href="javascript:void(0)">RecoSquareWinMultFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoStabCorrFilter" href="javascript:void(0)">RecoStabCorrFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoSumOfSquaresFilter" href="javascript:void(0)">RecoSumOfSquaresFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoTeeFilter" href="javascript:void(0)">RecoTeeFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoTraficWinMultFilter" href="javascript:void(0)">RecoTraficWinMultFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoTrajectoryFilter" href="javascript:void(0)">RecoTrajectoryFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoTransposeFilter" href="javascript:void(0)">RecoTransposeFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoTrapezWinMultFilter" href="javascript:void(0)">RecoTrapezWinMultFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoUnwrapFilter" href="javascript:void(0)">RecoUnwrapFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoUserWinMultFilter" href="javascript:void(0)">RecoUserWinMultFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoVarianceFilter" href="javascript:void(0)">RecoVarianceFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoWeightingFilter" href="javascript:void(0)">RecoWeightingFilter</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 80px; height: 22px;">&nbsp;</span><span class="label"><a class="RecoPublicStages.html:RecoZfillFilter" href="javascript:void(0)">RecoZfillFilter</a></span></div></li></ul></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="BaselevelPars.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/BaselevelPars.html">Baselevel Parameters</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="ReceiverGain.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/ReceiverGain.html">Receiver Gain</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Hardware.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Hardware.html">Hardware</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Shimming.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Shimming.html">Shimming</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Parameters.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Parameters.html">Parameters</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Programming.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Programming.html">Programming</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Spectroscopy.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Spectroscopy.html">Spectroscopy</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Adjustments.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Adjustments.html">Adjustments</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 64px; height: 22px;">&nbsp;</span><span class="label"><a class="Visu.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Visu.html">Visu</a></span></div></li></ul></li><li><div class="item"><span style="display: inline-block; width: 48px; height: 22px;">&nbsp;</span><span class="label"><a class="Toolboxes.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Toolboxes.html">Toolboxes</a></span></div></li></ul></li><li><div class="item"><a href="javascript:void(0)"><img style="padding-left: 16px;" width="16" height="22" border="0" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/arrowright.png"></a><span class="label"><a class="IsaModelProgramming.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/IsaModelProgramming.html">ISA Model Programming</a></span></div></li><li><div class="item"><span style="display: inline-block; width: 32px; height: 22px;">&nbsp;</span><span class="label"><a class="deprecated.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/deprecated.html">Deprecated List</a></span></div></li><li><div class="item"><a href="javascript:void(0)"><img style="padding-left: 16px;" width="16" height="22" border="0" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/arrowright.png"></a><span class="label"><a class="modules.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/modules.html">Modules</a></span></div></li><li><div class="item"><a href="javascript:void(0)"><img style="padding-left: 16px;" width="16" height="22" border="0" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/arrowright.png"></a><span class="label"><a class="annotated.html" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/annotated.html">Data Structures</a></span></div></li></ul></li></ul></div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
<div class="ui-resizable-handle ui-resizable-e"></div><div class="ui-resizable-handle ui-resizable-s"></div><div class="ui-resizable-handle ui-resizable-se ui-icon ui-icon-gripsmall-diagonal-se" style="z-index: 1001;"></div></div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('RecoPublicStages.html','');});
</script>
<div id="doc-content" style="margin-left: 262px; height: 1429px;">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" onclick="searchBox.OnSelectItem(0)" href="javascript:void(0)"><span class="SelectionMark">â€¢</span>All</a><a class="SelectItem" onclick="searchBox.OnSelectItem(1)" href="javascript:void(0)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" onclick="searchBox.OnSelectItem(2)" href="javascript:void(0)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" onclick="searchBox.OnSelectItem(3)" href="javascript:void(0)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" onclick="searchBox.OnSelectItem(4)" href="javascript:void(0)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" onclick="searchBox.OnSelectItem(5)" href="javascript:void(0)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" onclick="searchBox.OnSelectItem(6)" href="javascript:void(0)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" onclick="searchBox.OnSelectItem(7)" href="javascript:void(0)"><span class="SelectionMark">&nbsp;</span>Modules</a><a class="SelectItem" onclick="searchBox.OnSelectItem(8)" href="javascript:void(0)"><span class="SelectionMark">&nbsp;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Reconstruction Stages </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Overview"></a>
Overview</h1>
<table class="doxtable">
<tbody><tr>
<td valign="top"><p class="starttd"></p>
<p><b>Sources</b> (Please see also <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#DataDescriptor">DataDescriptor</a>)</p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoBufferSource">RecoBufferSource</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoDummySource">RecoDummySource</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoFileSource">RecoFileSource</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoParameterSource">RecoParameterSource</a></li>
</ul>
<p><b>Filters for manipulating the data structure</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoCastFilter">RecoCastFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoCombineFilter">RecoCombineFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoCutoffFilter">RecoCutoffFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoExtractFilter">RecoExtractFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoReformatFilter">RecoReformatFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRemoveFilter">RecoRemoveFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoReverseFilter">RecoReverseFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoShuffleProfilesFilter">RecoShuffleProfilesFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoSortFilter">RecoSortFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoSplitFilter">RecoSplitFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoTeeFilter">RecoTeeFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoTransposeFilter">RecoTransposeFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoZfillFilter">RecoZfillFilter</a></li>
</ul>
<p><b>Sinks</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoBufferSink">RecoBufferSink</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoDummySink">RecoDummySink</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoFileSink">RecoFileSink</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoParameterSink">RecoParameterSink</a></li>
</ul>
<p class="endtd"></p>
</td><td valign="top"><p class="starttd"></p>
<p><b>Filters for Fourier transformation</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoFTFilter">RecoFTFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoFTShiftFilter">RecoFTShiftFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoHalfFourierFilter">RecoHalfFourierFilter</a></li>
</ul>
<p><b>Filters for simple algebra</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoAddFilter">RecoAddFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoAverageFilter">RecoAverageFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoDivideFilter">RecoDivideFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMagnitudeFilter">RecoMagnitudeFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMeanFilter">RecoMeanFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMultFilter">RecoMultFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPhaseFilter">RecoPhaseFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoReImFilter">RecoReImFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoScaleFilter">RecoScaleFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoSquareRootFilter">RecoSquareRootFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoSumOfSquaresFilter">RecoSumOfSquaresFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoVarianceFilter">RecoVarianceFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoWeightingFilter">RecoWeightingFilter</a></li>
</ul>
<p><b>Windowing function filters</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoExpWinMultFilter">RecoExpWinMultFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoGaussWinMultFilter">RecoGaussWinMultFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoSincWinMultFilter">RecoSincWinMultFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoSineWinMultFilter">RecoSineWinMultFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoSquareWinMultFilter">RecoSquareWinMultFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoTraficWinMultFilter">RecoTraficWinMultFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoTrapezWinMultFilter">RecoTrapezWinMultFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoUserWinMultFilter">RecoUserWinMultFilter</a></li>
</ul>
<p class="endtd"></p>
</td><td valign="top"><p class="starttd"></p>
<p><b>Filters for specific methods</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoCpmgCorrFilter">RecoCpmgCorrFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoCalcTrajectoryFilter">RecoCalcTrajectoryFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoFidCorrFilter">RecoFidCorrFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoTrajectoryFilter">RecoTrajectoryFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoDetermineB0Filter">RecoDetermineB0Filter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoReloadB0Filter">RecoReloadB0Filter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoFlowFilter">RecoFlowFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPCAFilter">RecoPCAFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRGateApplyOrderFilter">RecoRGateApplyOrderFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRGateFindOrderFilter">RecoRGateFindOrderFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRGateDisplayFilter">RecoRGateDisplayFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoStabCorrFilter">RecoStabCorrFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoSpectCorrFilter">RecoSpectCorrFilter</a></li>
</ul>
<p><b>Filters operating on the phase</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoCorrPhaseFilter">RecoCorrPhaseFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoConjQnegFilter">RecoConjQnegFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPhasCorrFilter">RecoPhasCorrFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPhasedAccumFilter">RecoPhasedAccumFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPhaseDiffFilter">RecoPhaseDiffFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPhaseWeightingFilter">RecoPhaseWeightingFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoUnwrapFilter">RecoUnwrapFilter</a></li>
</ul>
<p class="endtd"></p>
</td><td valign="top"><p class="starttd"></p>
<p><b>Masking filters</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoCreateMaskFilter">RecoCreateMaskFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoAutoCreateMaskFilter">RecoAutoCreateMaskFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMaskFilter">RecoMaskFilter</a></li>
</ul>
<p><b>Mapping filters</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoHistogramFilter">RecoHistogramFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMinMaxFilter">RecoMinMaxFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMapFilter">RecoMapFilter</a></li>
</ul>
<p><b>Filters for parallel imaging</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPIGrappaCalibFilter">RecoPIGrappaCalibFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPIGrappaRecoFilter">RecoPIGrappaRecoFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPIRefExtractFilter">RecoPIRefExtractFilter</a></li>
</ul>
<p><b>Filters for non-Cartesian reconstruction</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoInverseFidFilter">RecoInverseFidFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRegridApodCorrFilter">RecoRegridApodCorrFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRegridDensCorrFilter">RecoRegridDensCorrFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRegridFilter">RecoRegridFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRegridNFilter">RecoRegridNFilter</a></li>
</ul>
<p><b>Other filters</b></p><ul>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoAnalyseFidFilter">RecoAnalyseFidFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoFrqOffsetFilter">RecoFrqOffsetFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMethodFilter">RecoMethodFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoSystemFilter">RecoSystemFilter</a></li>
<li><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPrintFilter">RecoPrintFilter</a></li>
</ul>
<p class="endtd"></p>
</td></tr>
</tbody></table>
<hr>
 <h1><a class="anchor" id="DataDescriptor"></a>
DataDescriptor</h1>
<p>Data streams between Reconstruction Stages are described by a set of 
parameters (the DataDescriptor), and are initialized in the sources. 
These parameters are: <br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>initFromACQP </td><td>Initialize data stream description from ACQP parameters of the associated data set. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>initFromRECO </td><td>Initialize data stream description from RECO parameters of the associated data set. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>nr </td><td>number of (independent) repetitions within data stream. 
nr=0 is used internally to describe setup experiments which are repeated
 a number of times not known a priori. nr=0 must not be set manually. </td><td>int </td><td>none </td><td>&gt;=0 </td><td>no </td><td>1  </td></tr>
<tr>
<td>dim </td><td>dimension of data set (without repetitions) </td><td>int </td><td>none </td><td>&gt;=0 </td><td>no </td><td>1  </td></tr>
<tr>
<td>sizes </td><td>sizes of the data array for each direction </td><td>int[dim] </td><td>none </td><td>&gt;=1 </td><td>no </td><td>{1}  </td></tr>
<tr>
<td>dataRep </td><td>internal data representation of data words </td><td>enum </td><td>none </td><td>SIGNED, UNSIGNED, FLOAT </td><td>no </td><td>SIGNED  </td></tr>
<tr>
<td>wordSize </td><td>number of bytes which are used to represent a single data word </td><td>int </td><td>none </td><td>1,2,4,8 </td><td>no </td><td>4  </td></tr>
<tr>
<td>baseField </td><td>flag to distinguish real and complex numbers </td><td>enum </td><td>none </td><td>REAL,COMPLEX </td><td>no </td><td>COMPLEX  </td></tr>
<tr>
<td>procDim </td><td>default dimension for buffer allocation - should describe the typical object size in the current processing pass. </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;dim </td><td>no </td><td>1  </td></tr>
<tr>
<td>frameDim </td><td>dimension of the logical data object. This is usually needed for mapping and is 2 for multi-slice and 3 for 3D datasets  </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;dim </td><td>no </td><td>1  </td></tr>
</tbody></table>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a></p>
<hr>
 <h1><a class="anchor" id="RecoAddFilter"></a>
RecoAddFilter</h1>
<p>Calculates the sum of all input data streams. The add filter combines
 multiple (identical) data streams to a single data stream which 
contains the (complex) sum of the elements from the input data streams.</p>
<p><b> Data Stream Requirements:</b><br>
 Currently, the add filter is implemented for real and complex double 
precision floating point numbers only. All input streams must be of the 
same type (real / complex).</p>
<p><b> Data Structure Translation:</b><br>
 The output stream will inherit its structure from the first input 
stream, while it is asserted that all input streams have the same 
structure.</p>
<p><b> Technical Details: </b><br>
 This filter does not operate inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
    RecoDummySource Q1{wordSize=8;dataRep=FLOAT;};
    RecoDummySource Q2{wordSize=8;dataRep=FLOAT;};
    RecoPrintFilter P1;
    RecoPrintFilter P2;
    RecoAddFilter   A;
    RecoPrintFilter P;
    RecoDummySink   S;
    Q1-&gt;P1-&gt;A; Q2-&gt;P2-&gt;A; A-&gt;P-&gt;S;
} 
// result: i + i = 2i
// [0.00000e+00 + i1.00000e+00]
// [0.00000e+00 + i1.00000e+00]
// [0.00000e+00 + i2.00000e+00] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoAnalyseFidFilter"></a>
RecoAnalyseFidFilter</h1>
<p>Analyses FID data. The analyse FID filter extracts amplitude, phase, 
T2*, and B0 offset from a 1D data vector. These values can be used, 
e.g., for improving algebraic image reconstruction.</p>
<p><b>Parameters:</b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit</th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>skip </td><td>initial part to be skipped </td><td>int </td><td>samples </td><td>&gt;= 0 : number of samples to be skipped<br>
 &lt; 0 : start from maximum within first abs(<em>skip</em>) samples </td><td>no </td><td>-16  </td></tr>
<tr>
<td>amplitude </td><td>(output parameter) amplitude of first point<br>
 to be used as value at k=0 for inverse reconstruction </td><td>double </td><td>- </td><td>&gt;= 0 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>phase </td><td>(output parameter) phase of first point<br>
 to be used for zero order phase correction </td><td>double </td><td>rad </td><td>-PI &lt; phase &lt; PI </td><td>yes </td><td>-  </td></tr>
<tr>
<td>t2 </td><td>(output parameter) T2* relaxation constant<br>
 estimated from exponential fit of signal amplitude<br>
 to be used for exponential filtering </td><td>double </td><td>multiple of FID length </td><td>&gt;= 0 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>b0 </td><td>(output parameter) B0 offset<br>
 estimated from time course of signal phase<br>
 to be used for off-resonance correction </td><td>double </td><td>rad per FID length </td><td>any </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 Shuffled, complex, double precision floating point data of any dimension.</p>
<p><b> Data Structure Translation: </b><br>
 The data is not modified.</p>
<p><b> Technical Details: </b><br>
 The filter can work inplace.</p>
<p><b>Example:</b><br>
 </p><pre class="fragment">/// simulated data
{
  // data
  RecoFileSource D
  {
    filename        = "fid30.dat";
    dim             = 1;
    procDim         = 1;
    sizes           = 16;
    dataRep         = FLOAT;
    wordSize        = 8;
    baseField       = COMPLEX;
  };
 
  RecoAnalyseFidFilter A
  {
    verbose = true;
  };
   
  RecoDummySink S;
  
  D-&gt;A;
  A-&gt;S;
}
// result
// amplitude = 17
// phase = -1.0472
// t2 = 0.4
// b0 = 15.708</pre><p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1 class=""><a class="anchor" id="RecoAverageFilter"></a>
RecoAverageFilter</h1>
<p>Averages or accumulates signals, supporting multiple interleaved 
objects and varying number of averages. The average filter averages data
 on the input stream, where the number of averages can be a list which 
is used cyclically. Multiple interleaved objects, to be averaged 
independently, are also supported.</p>
<p>For example, for 2 objects "a" and "b" and an averaging list avList={2,3}, the input data stream </p><pre class="fragment">a1, b1, a2, b2, a3, b3, a4, b4, a5, b5, ... 
</pre><p>will be averaged to: </p><pre class="fragment">(a1+a2)/2, (b1+b2)/2, (a3+a4+a5)/3, (b3+b4+b5)/3, ...
</pre><p><b> Size reduction:</b><br>
 The output sizes of the data can be specified directly (with newSize). 
In this case the specified sizes must match the size reduction caused by
 the averaging according to avList.</p>
<p>If newSize is not specified, the output sizes are calculated automatically, depending on the input size:</p>
<p>If the size of the second input dimension is a multiple of 
sum-of-avList times nObj (meaning that data is organized with averaging 
included in the second dimension), the size of the second dimension will
 be reduced.</p>
<p>Otherwise, the third dimension will be reduced, if that is a multiple
 of sum-of-avList, and the second dimension is a multiple of nObj 
(meaning that objects run in the second dimension and averages in the 
third).</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>avList </td><td>List of numbers-of-averages. </td><td>int array </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>avListSize </td><td>Size of the list </td><td>int </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>nObj </td><td>Number of separately averaged objects </td><td>int </td><td>none </td><td>- </td><td>no </td><td>1  </td></tr>
<tr>
<td>newSize </td><td>New output size </td><td>int[] </td><td>none </td><td>&gt;= 1 </td><td>no </td><td>-  </td></tr>
<tr>
<td>accumulate </td><td>flag whether data should be accumulated </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The filter is implemented for double precision floating point streams only (real and complex).</p>
<p>The filter should be used with procDim=1.</p>
<p><b>Technical Details:</b><br>
 The filter outputs results as soon as possible. In the example below, 
the average of the second object is printed before the second input for 
the second object is accepted. This behavior is intended.</p>
<p>The filter does not work inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">// RecoAverageFilter
{
    RecoDummySource Q {
    procDim=1;wordSize=8;dataRep=FLOAT;
    baseField=REAL;dim=2;sizes={1,10};        
        };

    RecoAverageFilter AV{avList={2,3}; avListSize=2; nObj=2}; 
    RecoPrintFilter P1{format="%.0f";separator=""};
    RecoPrintFilter P2{format="%.1f";};  //output with decimal digit 
    RecoDummySink S{verbose=false;};
    
    Q -&gt; P1 -&gt; AV -&gt; P2 -&gt; S;  
}
Result:
//[0] 
//[1] 
//[2] 
//-------------------------------------------
//[1.0] 
//-------------------------------------------
//[3] 
//-------------------------------------------
//[2.0] 
//-------------------------------------------
//[4] 
//[5] 
//[6] 
//[7] 
//[8] 
//-------------------------------------------
//[6.0] 
//-------------------------------------------
//[9] 
//-------------------------------------------
//[7.0] 
//-------------------------------------------</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoBufferSink"></a>
RecoBufferSink</h1>
<p>The buffer sink collects data in an internal memory buffer. The 
buffer sink is used to interchange data between passes. The data usually
 will be read by subsequent passes. Memory buffers can refer to global 
memory blocks, which can be reused for multiple passes.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>bufferId </td><td>global string ID to refer to buffer </td><td>string </td><td>none </td><td>arbitrary string </td><td>yes </td><td>-  </td></tr>
<tr>
<td>memId </td><td>global string ID to refer to global memory region, to allow reusage of global memory regions  </td><td>string </td><td>none </td><td>arbitrary string </td><td>yes </td><td>-  </td></tr>
<tr>
<td>display </td><td>flag to control graphical display of buffer data. This feature is experimental and not officially supported.  </td><td>bool </td><td>none </td><td>false/true </td><td>no </td><td>false  </td></tr>
<tr>
<td>reorder </td><td>flag to control reordering of buffer data. This feature is experimental and not officially supported.  </td><td>bool </td><td>none </td><td>false/true </td><td>no </td><td>false  </td></tr>
<tr>
<td>phaseFactor </td><td>parameter to control interleaving for reordering. This feature is experimental and not officially supported.  </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;size </td><td>no </td><td>1  </td></tr>
</tbody></table>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
    RecoDummySource Q;
    RecoBufferSink S{bufferId="A"; memID="0";};
    Q-&gt;S;
}
{   RecoBufferSource Q{bufferId="A";}; // no memId used here!
    RecoPrintFilter P;
    RecoDummySink S;
    Q-&gt;P-&gt;S;
}
// result:
// [0 + i1] </pre><p> <br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoBufferSource"></a>
RecoBufferSource</h1>
<p>The buffer source delivers data from an existing data buffer. The 
buffer source attaches to an existing buffer referenced by a string ID 
and then copies data from the buffer into the output carrier by request.
 It is usually used to obtain data from a previous pass, in which a <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoBufferSink">RecoBufferSink</a> has defined and filled the data buffer.</p>
<p>The data stream on the outgoing carrier is initialized with the data description of the data buffer object.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>bufferId </td><td>Arbitrary String to identify global buffer object </td><td>string </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p>In addition, parameters listed under <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#DataDescriptor">DataDescriptor</a> can be specified.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q;
   RecoPrintFilter P;
   RecoBufferSink S{bufferId="A"};
   Q-&gt;P-&gt;S;
}
{
   RecoBufferSource Q{bufferId="A"};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;P-&gt;S;
}
// result:
// [0 + i1]
// [0 + i1]</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoCalcTrajectoryFilter"></a>
RecoCalcTrajectoryFilter</h1>
<p>Performs EPI trajectory calculation. This filter performs EPI 
trajectory calculation from data acquired during the adjustment of an 
EPI measurement. The input data, from which three return parameters are 
calculated, is directly passed on to the output.</p>
<p>The parameters returned are the trajectory (k_x coordinates stored in
 kxtraj[]), the B0 phase (stored in b0traj[]) and a flag indicating, 
whether the calculated trajectory is valid (traj_measured). The 
calculation corresponds to that of the pipeline filter pfObserveGrad and
 is described in the paper by Zhang et al.<br>
</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>offset </td><td>Number of complex data points for navigator </td><td>int </td><td>none </td><td>non-negative </td><td>no </td><td>0  </td></tr>
<tr>
<td>xres </td><td>Number of complex data points for one k-space line </td><td>int </td><td>none </td><td>non-negative </td><td>yes </td><td>-  </td></tr>
<tr>
<td>yres </td><td>Number of k-space lines (one segment assumed)  </td><td>int </td><td>none </td><td>non-negative </td><td>yes </td><td>-  </td></tr>
<tr>
<td>cstep </td><td>Number of the central k-space line (given by PVM_EncCentralStep1)  </td><td>int </td><td>none </td><td>non-negative </td><td>yes </td><td>-  </td></tr>
<tr>
<td>dist_fov_ratio </td><td>ratio center_distance / fov_read </td><td>double </td><td>none </td><td>non-negative </td><td>no </td><td>0.25  </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 This filter can operate inplace.</p>
<p><b> References: </b><br>
 "A Novel k-Space
 Trajectory Measurement Technique", Zhang et al., MRM 39:999-1004 (1998) <br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoCastFilter"></a>
RecoCastFilter</h1>
<p>Changes the data type of a stream. The cast filter converts input 
data to a different data type similar to a type cast in the C 
programming language. This operation may change both the data 
representation (SIGNED / UNSIGNED / FLOAT) and the word size, but only 
supported combinations of wordSize and dataRep may be used.</p>
<p>No tests are performed before the conversion, whether range or 
precision are lost. In order to avoid overflows, data mapping must be 
performed in advance. If no parameters are given, the data type is not 
modified.</p>
<p>The cast filter cannot be used to convert between real and complex data.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>wordSize </td><td>number of bytes of each output word </td><td>int </td><td>none </td><td>1,2,4,8 </td><td>No </td><td>-  </td></tr>
<tr>
<td>dataRep </td><td>data representation of the output </td><td>enum </td><td>none </td><td>SIGNED, UNSIGNED, FLOAT </td><td>No </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Structure Translation: </b><br>
 The output data stream will have the word size and data representation 
requested by the parameters. All other properties remain unchanged.</p>
<p><b> Technical Details: </b><br>
 The filter will operate inplace, if and only if the word size does not change.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
      RecoDummySource Q{wordSize=4;dataRep=UNSIGNED;offset=34000;};
      RecoPrintFilter P1;
      RecoCastFilter C{wordSize=2; dataRep=SIGNED;};
      RecoPrintFilter P2;
      RecoDummySink S;
      Q-&gt;P1-&gt;C-&gt;P2-&gt;S;
}
// resulting in
// [34000 + i34001]
// [-31536 - i31535] </pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoCombineFilter"></a>
RecoCombineFilter</h1>
<p>Combines equivalent data streams into one stream. The combine filter 
merges several identical streams into a single data stream. The format 
of the data streams may be arbitrary, but all of the data streams must 
have the same format.<br>
</p>
<p>The order how data is interleaved depends on the order in which the 
inputs are connected during creation of the network, i.e. if the network
 description contains Q1-&gt;C; Q2-&gt;C; then first data from Q1 and 
then from Q2 will appear on the merged stream. <br>
</p>
<p>The operation is controlled by four parameters which describe the 
dimension of sub-blocks (dim, less or equal to the total block 
dimension, totalDim), which will be treated as units, and the number of 
consecutive sub-blocks (blockCnt) which will be read subsequently from 
the same input. The derivation of the resulting data descriptor is 
controlled by the parameter keepBlocksize.</p>
<p>A special mode for two connectors is provided for the UTE method for 
the case of two input connectors and double valued data. Here, the last 
point of the first and the first point of the second block are averaged.
 The content of the second block is then shifted by one point and the 
last point is zero-filled.</p>
<p><b> Connectors: </b><br>
 This filter supports up to 1024 unnamed input connectors. The data 
interleaving sequence is given by the order in which the inputs are 
connected.<br>
</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>dim </td><td>dimension of the sub-blocks to combine </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;totalDim </td><td>no </td><td>procDim  </td></tr>
<tr>
<td>blockCnt </td><td>Number of subsequent blocks of dimension dim, which will be read from the same input. </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;sizes[dim-1] </td><td>no </td><td>1  </td></tr>
<tr>
<td>keepBlocksize </td><td>Flag to control data descriptor translation. See section Data Structure Translation below for details. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>procDim </td><td>desired output processing dimension </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;totalDim </td><td>no </td><td>input procDim  </td></tr>
<tr>
<td>average </td><td>Flag whether averaging should be performed on the first/last point (special mode for UTE sequences). </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 All input streams must have identical descriptions. Averaging mode is implemented for double data and two inputs only.</p>
<p><b> Data Structure Translation: </b><br>
 The output data description is derived from the input data description 
and the keepBlocksize parameter. If keepBlocksize is set to false 
(default), the output data descriptor size corresponding to the 
sub-blocks is multiplied by the number of inputs, i.e. the sub-blocks 
are combined to form larger sub-blocks. If keepBlocksize is set to true,
 the output data sizes describing the sub-blocks remain unchanged, and 
the data descriptor size above the sub-block dimension is multiplied by 
the number of inputs. If there is no dimension above the sub-block 
dimension, the dimension of the data descriptor is increased by one and 
its size is set to the number of inputs.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">// example for blockCnt=1
{
    RecoDummySource Q1{dim=2;sizes={2,2};dataRep=SIGNED;wordSize=4;
                       baseField=REAL;procDim=2;};
    RecoDummySource Q2{dim=2;sizes={2,2};dataRep=SIGNED;wordSize=4;
                       baseField=REAL;procDim=2;};
    RecoCombineFilter C{dim=1;blockCnt=1;keepBlocksize=true};
    RecoPrintFilter P;
    RecoDummySink S;
    Q1-&gt;C;
    Q2-&gt;C;
    C-&gt;P-&gt;S;
}
// result:
//  [0] [1] [0] [1] [2] [3] [2] [3]
// -----------------------------------------------------------------
// example for blockCnt=2
{
    RecoDummySource Q1{dim=2;sizes={2,2};dataRep=SIGNED;wordSize=4;
                       baseField=REAL;procDim=2;};
    RecoDummySource Q2{dim=2;sizes={2,2};dataRep=SIGNED;wordSize=4;
                       baseField=REAL;procDim=2;};
    RecoCombineFilter C{dim=1;blockCnt=2;keepBlocksize=true};
    RecoPrintFilter P;
    RecoDummySink S;
    Q1-&gt;C;
    Q2-&gt;C;
    C-&gt;P-&gt;S;
}
// result:
//  [0] [1] [2] [3] [0] [1] [2] [3]
// -----------------------------------------------------------------
// example for keepBlocksize=true
{
    RecoDummySource Q{dim=3;sizes={2,4,2};dataRep=SIGNED;wordSize=4;
                       baseField=REAL;procDim=2;};
    RecoSplitFilter Sp{dim=1;blockCnt=2;keepBlocksize=true};
    RecoCombineFilter C{dim=1;blockCnt=2;keepBlocksize=true};
    RecoPrintFilter P;
    RecoDummySink S{verbose=true};
    Q-&gt;Sp;
    Sp-&gt;C;
    Sp-&gt;C;
    C-&gt;P-&gt;S;
}
// result:
//Sink&lt;S&gt; ...
// 2 4 2
//
// [0] [1] [2] [3] [4] [5] [6] [7]
// [8] [9] [10] [11] [12] [13] [14] [15]
// ---------------------------------------------------------------
//
// example for keepBlocksize=false
{
    RecoDummySource Q{dim=3;sizes={2,4,2};dataRep=SIGNED;wordSize=4;
                       baseField=REAL;procDim=2;};
    RecoSplitFilter Sp{dim=1;blockCount=2;keepBlocksize=true};
    RecoCombineFilter C{dim=1;blockCount=2;keepBlocksize=false};
    RecoPrintFilter P;
    RecoDummySink S{verbose=true};
    Q-&gt;Sp;
    Sp-&gt;C;
    Sp-&gt;C;
    C-&gt;P-&gt;S;
}
// result:
//Sink&lt;S&gt; ...
// 4 2 2
//
// [0] [1] [2] [3] [4] [5] [6] [7]
// [8] [9] [10] [11] [12] [13] [14] [15]
// ---------------------------------------------------------------
//
// example for average=true
{
    RecoDummySource Q1{dim=2;sizes={2,2};dataRep=FLOAT;wordSize=8;
                       baseField=REAL;procDim=2;};
    RecoDummySource Q2{dim=2;sizes={2,2};dataRep=FLOAT;wordSize=8;
                       baseField=REAL;procDim=2;};
    RecoCombineFilter C{dim=1;blockCnt=1;keepBlocksize=false;average=true;
                        procDim=2;};
    RecoPrintFilter P{format="%4.2f"};
    RecoDummySink S;
    Q1-&gt;C;
    Q2-&gt;C;
    C-&gt;P-&gt;S;
}
// result:
// [0.00] [0.50] [1.00] [0.00] [2.00] [2.50] [3.00] [0.00]
</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoConjQnegFilter"></a>
RecoConjQnegFilter</h1>
<p>Performs conjugation of complex input data and/or negation of even 
points. The ConjQneg filter can perform so called quadrature correction</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>direction </td><td>Spatial direction to perform correction for, counting from 0. </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;dim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>conjugate </td><td>Flag controlling complex conjugation. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>negate </td><td>Flag controlling the negation of even points </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
</tbody></table>
<p><br>
 <b> Data Stream Requirements:</b><br>
 The function works on complex floating point data streams only. The 
processing dimension must be at least equal to the processing direction +
 1 (counting direction from 0 and dimensions from 1)</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={2};dataRep=FLOAT};
   RecoPrintFilter P1;
   RecoConjQnegFilter C{negate=true;conjugate=true};
   RecoPrintFilter P2;
   RecoDummySink S;
   Q-&gt;P1-&gt;C-&gt;P2-&gt;S;
}
// result:
// [0.00000e+00 + i1.00000e+00][2.00000e+00 + i3.00000e+00]
// [0.00000e+00 - i1.00000e+00][-2.00000e+00 + i3.00000e+00] </pre><p><br>
  <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoCorrPhaseFilter"></a>
RecoCorrPhaseFilter</h1>
<p>Corrects all time frames with the phase of a selected time frame. 
This filter is used in methods where an image time series is acquired 
and real data is created (e.g. inversion recovery techniques). In this 
case, the phase is removed using one image of the series as reference.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit</th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>slices </td><td>number of slices </td><td>unsigned int </td><td>- </td><td>&gt; 0 </td><td>no </td><td>1  </td></tr>
<tr>
<td>frame </td><td>frame number used for phase correction </td><td>int </td><td>- </td><td>&gt;= 0<br>
frame=-1: use last frame </td><td>no </td><td>-1  </td></tr>
<tr>
<td>order </td><td>order of time and slice loop </td><td>unsigned int </td><td>- </td><td>0 = time inside slice loop<br>
 1 = time outside slice loop </td><td>no </td><td>0  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements: </b><br>
 The structure of the input data must be as follows: </p><ul>
<li>
The input data must be shuffled complex, double precision floating point data of dimension &gt;= 1.  </li>
<li>
The dimension <em>frameDim</em> + 1 is expected to hold all images, i. e. the movie frames and slices, interleaved in the order given by the <em>order</em> parameter. </li>
</ul>
<p><b> Data Structure Translation: </b><br>
 The structure of output data will be identical to the input data.</p>
<p><b> Technical Details: </b><br>
 The filter works inplace. <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoCpmgCorrFilter"></a>
RecoCpmgCorrFilter</h1>
<p>Calculates corrections of the CPMG conditions. Requires the echo 
train to be repeated twice for all slices, with the excitation pulse 
rotated by 90 degrees in the second repetition. This allows separation 
of the two echo components and obtaining the phase correction and 
read-dephasing correction from the zero- and first-order phase 
differences between their spectra.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>nEchoes </td><td>Number of echoes </td><td>int </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>nSlices </td><td>Number of slices </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;1024 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>phaseCorr </td><td>Parameter to hold the calculated phase correction. </td><td>double </td><td>deg </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>readCorr </td><td>Parameter to hold the calculated read dephasing correction. </td><td>double </td><td>deg/pix </td><td>- </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The filter is implemented for floating point streams only.<br>
</p>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoCreateMaskFilter"></a>
RecoCreateMaskFilter</h1>
<p>Creates a mask based on a background noise estimate. The create mask 
filter assumes that there are at least two corners of the data matrix 
(2D or 3D) where no signal is expected. The mean of the values in the 
two "darkest" corners is taken as the noise level. Then, a binary mask 
is created which is set to one for pixels that exceed the thresholds </p><ul>
<li>
parameter "snr" times the noise level </li>
<li>
parameter "signalLevel" times the maximum image intensity </li>
</ul>
<p>The mask is set to zero elsewhere. In case both "snr" and 
"signalLevel" are given, the mask is set to one for pixels that exceed 
the larger of the two thresholds.</p>
<p>This filter has one input connector: </p><ul>
<li>
Two- or three-dimensional double precision floating point data, real or complex. </li>
</ul>
<p>There are two named output connectors: </p><ol>
<li>
Connector "mask": Real signed char data of same size as input containing zeros (no signal) and ones (signal). </li>
<li>
Connector "data": Unchanged input data. </li>
</ol>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>snr </td><td>Signal threshold in units of estimated background noise. If set to zero, there is no SNR threshold. </td><td>double </td><td>none </td><td>&gt;=0.0 </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>cornerPart </td><td>Estimate noise in cube corners up to this fraction of image size </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;1.0 </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>signalLevel </td><td>Signal threshold relative to maximum image intensity. If set to zero, there is no such threshold. </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;1.0 </td><td>no </td><td>0.0  </td></tr>
</tbody></table>
<p>When using the default parameters, the mask values will be equal to one everywhere on the matrix.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
  RecoParameterSource Q 
  {
    dim = 2;
    frameDim = 2;
    procDim = 2;
    sizes = {8, 8};
    dataRep = FLOAT;
    wordSize = 8;
    baseField = REAL;
    data = {0.0, 0.1, 1.0, 1.0, 1.0, 1.0, 0.1, 0.0,
            0.1, 0.1, 1.0, 1.0, 1.0, 1.0, 0.1, 0.1,
            0.2, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.6,
            0.3, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.7,
            0.4, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.8,
            0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.9,
            0.1, 0.1, 1.0, 1.0, 1.0, 1.0, 0.1, 0.1,
            0.0, 0.1, 1.0, 1.0, 1.0, 1.0, 0.1, 0.0};
  };
 
  RecoCreateMaskFilter CM{snr=10.0;cornerPart=0.25};

  RecoPrintFilter Pmask{rowsize=8};
  RecoPrintFilter Pdata{rowsize=8;format="%1.2f"};
  
  RecoDummySink Smask;
  RecoDummySink Sdata;  
   
  Q-&gt;CM;
  CM.data-&gt;Pdata-&gt;Sdata;
  CM.mask-&gt;Pmask-&gt;Smask;
}
// Result:
// -------------------------------------------
// [0.00] [0.10] [1.00] [1.00] [1.00] [1.00] [0.10] [0.00] 
// [0.10] [0.10] [1.00] [1.00] [1.00] [1.00] [0.10] [0.10] 
// [0.20] [1.00] [1.00] [1.00] [1.00] [1.00] [1.00] [0.60] 
// [0.30] [1.00] [1.00] [1.00] [1.00] [1.00] [1.00] [0.70] 
// [0.40] [1.00] [1.00] [1.00] [1.00] [1.00] [1.00] [0.80] 
// [0.50] [1.00] [1.00] [1.00] [1.00] [1.00] [1.00] [0.90] 
// [0.10] [0.10] [1.00] [1.00] [1.00] [1.00] [0.10] [0.10] 
// [0.00] [0.10] [1.00] [1.00] [1.00] [1.00] [0.10] [0.00] 
// 
// -------------------------------------------
// -------------------------------------------
// [0] [0] [1] [1] [1] [1] [0] [0] 
// [0] [0] [1] [1] [1] [1] [0] [0] 
// [0] [1] [1] [1] [1] [1] [1] [0] 
// [0] [1] [1] [1] [1] [1] [1] [1] 
// [0] [1] [1] [1] [1] [1] [1] [1] 
// [0] [1] [1] [1] [1] [1] [1] [1] 
// [0] [0] [1] [1] [1] [1] [0] [0] 
// [0] [0] [1] [1] [1] [1] [0] [0] 
// 
// -------------------------------------------
</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoAutoCreateMaskFilter"></a>
RecoAutoCreateMaskFilter</h1>
<p>Automatic mask computation. The filter uses thresholding algorithms 
to automatically compute a threshold below which the mask is set to zero
 and above which the mask is set to one.<br>
 The input data needs to be non-complex and of double precision.<br>
 The output mask is of the same size as the input data but of type "char".<br>
</p>
<p>The filter has one input connector: </p><ul>
<li>
Two- or three-dimensional double precision floating point data, real or complex. </li>
</ul>
<p>And there are two named output connectors: </p><ul>
<li>
Connector "mask": Real signed char data of same size as input containing zeros (no signal) and ones (signal). </li>
<li>
Connector "data": Unchanged input data. </li>
</ul>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name </th><th>Description </th><th>Type </th><th>Unit </th><th>Values </th><th>Required </th><th>Default  </th></tr>
<tr>
<td>type </td><td>Optional: Specifies the thresholding algorithm to be used. </td><td>char* </td><td>none </td><td>otsu, li </td><td>no </td><td>otsu  </td></tr>
<tr>
<td>nbins </td><td>Optional: Specifies the number of histogram bins (Only for histogram based thresholding algorithms, e.g. "otsu"). </td><td>int </td><td>none </td><td>&gt;0 </td><td>no </td><td>256  </td></tr>
</tbody></table>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
    RecoParameterSource Q 
    {
        dim = 2;
        frameDim = 2;
        procDim = 2;
        sizes = {8, 8};
        dataRep = FLOAT;
        wordSize = 8;
        baseField = REAL;
        data = {0.0, 0.1, 1.0, 1.0, 1.0, 1.0, 0.1, 0.0,
                0.1, 0.1, 1.0, 1.0, 1.0, 1.0, 0.1, 0.1,
                0.2, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.6,
                0.3, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.7,
                0.4, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.8,
                0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.9,
                0.1, 0.1, 1.0, 1.0, 1.0, 1.0, 0.1, 0.1,
                0.0, 0.1, 1.0, 1.0, 1.0, 1.0, 0.1, 0.0};
    };

    RecoAutoCreateMaskFilter CM{type="li"};

    RecoPrintFilter Pdata{rowsize=8;format="%1.2f"};
    RecoPrintFilter Pmask{rowsize=8};

    RecoDummySink Smask;
    RecoDummySink Sdata;  

    Q-&gt;CM;
    CM.data-&gt;Pdata-&gt;Sdata;
    CM.mask-&gt;Pmask-&gt;Smask;
}

// Result:
// -------------------------------------------
// [0.00] [0.10] [1.00] [1.00] [1.00] [1.00] [0.10] [0.00] 
// [0.10] [0.10] [1.00] [1.00] [1.00] [1.00] [0.10] [0.10] 
// [0.20] [1.00] [1.00] [1.00] [1.00] [1.00] [1.00] [0.60] 
// [0.30] [1.00] [1.00] [1.00] [1.00] [1.00] [1.00] [0.70] 
// [0.40] [1.00] [1.00] [1.00] [1.00] [1.00] [1.00] [0.80] 
// [0.50] [1.00] [1.00] [1.00] [1.00] [1.00] [1.00] [0.90] 
// [0.10] [0.10] [1.00] [1.00] [1.00] [1.00] [0.10] [0.10] 
// [0.00] [0.10] [1.00] [1.00] [1.00] [1.00] [0.10] [0.00] 
// 
// -------------------------------------------
// -------------------------------------------
// [0] [0] [1] [1] [1] [1] [0] [0] 
// [0] [0] [1] [1] [1] [1] [0] [0] 
// [0] [1] [1] [1] [1] [1] [1] [1] 
// [0] [1] [1] [1] [1] [1] [1] [1] 
// [0] [1] [1] [1] [1] [1] [1] [1] 
// [1] [1] [1] [1] [1] [1] [1] [1] 
// [0] [0] [1] [1] [1] [1] [0] [0] 
// [0] [0] [1] [1] [1] [1] [0] [0] 
// 
// -------------------------------------------
</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoCutoffFilter"></a>
RecoCutoffFilter</h1>
<p>Extracts sub-blocks from the input data block. The cutoff filter 
extracts a sub-block from the input data block, as specified by the 
resulting sizes and offsets. A frame dimension must be specified to 
define in which directions the cutoff is to be performed. Sizes are 
currently specified as absolute (point) sizes, because these sizes are 
given in standard applications and to avoid rounding problems.</p>
<div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/CutoffFilter.png" alt="CutoffFilter.png">
<div class="caption">
Two-dimensional Frame Cutoff</div></div>
<p> <b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>frameDim </td><td>Dimension of the frames for which the cutoff is performed </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;dim </td><td>no </td><td>dim  </td></tr>
<tr>
<td>offset </td><td>Offset for the start of the cutoff </td><td>int[frameDim] </td><td>points </td><td>0&nbsp;...&nbsp;inputsize[i]-1 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>sizes </td><td>Spatial sizes for the resulting block </td><td>int[frameDim] </td><td>points </td><td>1&nbsp;...&nbsp;inputsize[i] </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p><br>
</p>
<p><b> Data Stream Requirements:</b><br>
 The procDim must be larger or equal to frameDim<br>
</p>
<p><b> Data Structure Translation: </b><br>
 Output sizes will be calculated from the sizes parameter.<br>
</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=2;sizes={3,4};procDim=2;};
   RecoPrintFilter P1{rowSize=3;};
   RecoCutoffFilter F{offset={1,2};sizes={1,2};};
   RecoPrintFilter P2;
   RecoDummySink S;
   Q-&gt;P1-&gt;F-&gt;P2-&gt;S;
}
// result:
// [0 + i1][2 + i3][4 + i5]
// [6 + i7][8 + i9][10 + i11]
// [12 + i13][14 + i15][16 + i17]
// [18 + i19][20 + i21][22 + i23]
//
// [14 + i15][20 + i21]</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoDetermineB0Filter"></a>
RecoDetermineB0Filter</h1>
<p>Determines B0 offset from an FID signal. From the input data (e.g. 
navigator signals), B0 offsets are calculated and passed to an ACQ 
parameter. This ACQ parameter can then be used by RecoReloadB0Filter.</p>
<p>For higher accuracy and/or stability more than one scan can be 
collected for the calculation of the B0 offset (width). After a 
calculation (and the B0-reload involved) a number of scans can be 
excluded from subsequent data collection to ensure transaction integrity
 (step).</p>
<p>The value of the B0 offset is set in [Hz] relative to a reference 
frequency that is determined from the first 'width' scans of the 
experiment.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>width </td><td>Number of scans to be collected for B0 determination </td><td>int </td><td>none </td><td>non-negative </td><td>no </td><td>1  </td></tr>
<tr>
<td>step </td><td>Number of scans to be skipped after setting of B0 </td><td>int </td><td>none </td><td>non-negative </td><td>no </td><td>0  </td></tr>
<tr>
<td>sampleBW </td><td>Sampling bandwidth of input data  </td><td>double </td><td>Hz </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>B0Value </td><td>Name of ACQ parameter to which the determined B0 offset is returned </td><td>string </td><td>- </td><td>- </td><td>yes </td><td>none  </td></tr>
<tr>
<td>activeReceivers </td><td>number of active receivers </td><td>int </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>debugFiles </td><td>Flag to create a file 'b0offset' in expno directory containing the calculated B0 offsets </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
</tbody></table>
<p><b>Data Structure Translation: </b><br>
 The input data, from which the frequency offset is calculated, is directly passed on to the output.</p>
<p><b>Data Stream Requirements: </b><br>
 The filter works on complex double precision floating point data only. <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoDivideFilter"></a>
RecoDivideFilter</h1>
<p>Divides input data by a constant value. The divide filter performs a 
point-wise division of the input data by a divisor specified as a 
parameter.</p>
<p><b>Parameters:</b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>divisor </td><td>Each input value will be divided by this divisor. </td><td>double </td><td>none </td><td>non-zero </td><td>no </td><td>1.0  </td></tr>
</tbody></table>
<p><b>Data Stream Requirements:</b><br>
 The filter operates on double precision floating point data only.</p>
<p><b> Technical Details: </b><br>
 This filter can operate inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
  RecoDummySource  Q{dim=1;sizes={4};dataRep=FLOAT;wordSize=8;baseField=REAL};
  RecoPrintFilter  PI{format="%.2f"};
  RecoDivideFilter D{divisor=2.0;};
  RecoPrintFilter  PO{format="%.2f"};
  RecoDummySink S;

  Q -&gt; PI -&gt; D -&gt; PO -&gt; S;
}
// Result:
//
// -------------------------------------------
// [0.00] [1.00] [2.00] [3.00] 
// -------------------------------------------
// -------------------------------------------
// [0.00] [0.50] [1.00] [1.50] 
// -------------------------------------------
// </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoDummySink"></a>
RecoDummySink</h1>
<p>Accepts and discards data without side effect. The dummy sink acts 
like a null device discarding all data that is written to it. It can be 
used for tests or when only intermediate results of a data stream are of
 interest. It works silently and without parameters on each type of data
 stream. The data descriptor of the input stream can be displayed with 
the (common) debug option "verbose".</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q;
   RecoDummySink S{verbose=true};
   Q-&gt;S;
}
// Result: 
//
// standalone[0]:S:initStageProcessing
// Sink&lt;standalone[0]:S&gt;
// nrRep: 1
// wordSize:           4
// baseField:          COMPLEX
// dataRepresentation: SIGNED
// blockDimension:     1
// frameDimension:     1
// procDimension:      1
// 1   </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoDummySource"></a>
RecoDummySource</h1>
<p>Test source that creates synthetic data. The purpose of the dummy 
source is to provide data not from external sources but to create data 
internally. The name dummy source is somewhat misleading, as it creates 
not null data but has a couple of modes which offer some flexibility. <br>
 The size and structure of the created data is described by the generic 
data description parameters. By default, consecutive data words are 
filled with consecutive (integer) numbers starting from 0 and not 
distinguishing between real and complex data streams. I.e. 0+i is the 
first data point. An offset may be defined to start with a different 
point. If the constant flag is set, the same data value will be 
repeated. The random/seed parameters will use the system random number 
generator to produce a random output pattern using the math/rand_r 
function. Finally a data parameter array may be defined to give a 
pattern which will repeated. See below examples for the different cases:</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>random </td><td>select random mode </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>seed </td><td>seed value for random mode, will overwrite data / constant options </td><td>int </td><td>none </td><td>&gt;=0 </td><td>no </td><td>42  </td></tr>
<tr>
<td>offset </td><td>offset value for data, can be combined with other options </td><td>int </td><td>none </td><td>- </td><td>no </td><td>0  </td></tr>
<tr>
<td>constant </td><td>flag to create constant data, will overwrite data option </td><td>int </td><td>none </td><td>- </td><td>no </td><td>0  </td></tr>
<tr>
<td>data </td><td>list of fixed (real) data value for output, will be cycled through if more points are specified than used. </td><td>double[] </td><td>none </td><td>- </td><td>no </td><td>{}  </td></tr>
</tbody></table>
<p>In addition to these parameters, parameters listed under <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#DataDescriptor">DataDescriptor</a> can and should be specified in most cases.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={3};baseField=REAL;wordSize=4;dataRep=SIGNED;};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;P-&gt;S;
}
// result: [0][1][2]
{
   RecoDummySource Q{dim=1;sizes={3};baseField=REAL;wordSize=4;dataRep=SIGNED;
                      offset = 1;};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;P-&gt;S;
}
// result: [1][2][3]
{
   RecoDummySource Q{dim=1;sizes={3};baseField=REAL;wordSize=4;dataRep=SIGNED;
                     constant=true;offset=2;};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;P-&gt;S;
}
// result: [2][2][2]
{
   RecoDummySource Q{dim=1;sizes={3};baseField=REAL;wordSize=4;dataRep=SIGNED;
                     random = true; seed = 3;};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;P-&gt;S;
}
// result: [1430195325][125974964][80928584]
{
   RecoDummySource Q{dim=1;sizes={4};baseField=REAL;wordSize=4;dataRep=SIGNED;
                      data = {4,2,1};};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;P-&gt;S;
}
// result: [4][2][1][4]
{
   RecoDummySource Q{dim=1;sizes={3};baseField=COMPLEX;wordSize=4;dataRep=SIGNED;
                     data = { 2,1,3,4 };};

   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;P-&gt;S;
}
// result: [2 + i1][3 + i4][2 + i1] </pre><p><br>
 <b> References: </b><br>
 man 3 rand_r <br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoExpWinMultFilter"></a>
RecoExpWinMultFilter</h1>
<p>Exponential window multiplication. This filter performs exponential 
window multiplication on an arbitrary spatial direction. The exponential
 function is parametrized by a single parameter <b>delta</b> which describes the decay of the exponential function </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \exp\left(-\frac{\pi}{2} \delta t\right) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_13.png">
</p>
<p> ranging from in the domain <img class="formulaInl" alt="$[0,1)$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_14.png">.</p>
<div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/RecoExpWin.png" alt="RecoExpWin.png">
<div class="caption">
Exponential window function</div></div>
<p> To be precise, on a data block with N points, the i-th point will be multiplied by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \exp\left(-\frac{\pi}{2}\;\delta\;\frac{i-1}{N}\right) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_15.png">
</p>
<p> where i ranges from 1 to N.</p>
<p>To maintain compatibility with given topspin parameters, 
alternatively, delta can be derived from parameters LB, SW which define 
line broadening and sweep width: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \delta = 2\frac{\rm LB}{\rm SW}\;{\rm size} \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_16.png">
</p>
<p> Applied to a constant function this will result in an exponential 
function for which the Fourier transform (Lorentz-curve) has linewidth 
LB.</p>
<p>Note: In topspin-documentation you will find </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \delta = \frac{\rm LB}{\rm SW}\;{\rm size} \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_17.png">
</p>
<p> but there the decay constant is applied to data with real/imaginary 
parts interleaved. In the RecoWinMultFilterBase, both real and imaginary
 parts are multiplied with a single filter function value, so the decay 
constant must be double when filtering complex values as compared to 
interleaved real and imaginary values.</p>
<p><b>Parameters:</b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>winDirection </td><td>Direction for filter execution </td><td>init </td><td>none </td><td>0&nbsp;...&nbsp;procDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>delta </td><td>decay coefficient </td><td>double </td><td>none </td><td>- </td><td>no, if LB/SW set  </td><td>-  </td></tr>
<tr>
<td>LB </td><td>line broadening factor </td><td>double </td><td>Hertz </td><td>- </td><td>no, if delta set </td><td>-  </td></tr>
<tr>
<td>SW </td><td>sweep width  </td><td>double </td><td>Hertz </td><td>true/false </td><td>no, if delta set </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The filter works on real and complex floating point input streams. The 
processing dimension must match the selected winDirection.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={4};dataRep=FLOAT;wordSize=4;baseField=REAL;
                     offset=1;constant=true};
   RecoExpWinMultFilter W{delta = 1};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;W-&gt;P-&gt;S;
}
// result:
// [1.00000e+00][6.75232e-01][4.55938e-01][3.07864e-01]</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoExtractFilter"></a>
RecoExtractFilter</h1>
<p>Extracts profiles from a series of profiles. A profile is one-dimensional data in the first data dimension.<br>
 The total number of profiles in the input data are considered to form groups of size <em>nGroup</em>. From each group the first <em>nProfiles</em> profiles are extracted, i.e. currently no offset is possible.</p>
<p><b>Parameters:</b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit</th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>nGroup </td><td>number of profiles per group </td><td>unsigned int </td><td>- </td><td>1 &lt; <em>nGroup</em> &lt; total number of profiles in data<br>
 total number must be a multiple of <em>nGroup</em> </td><td>no </td><td>total number of profiles in data  </td></tr>
<tr>
<td>nProfiles </td><td>number of extracted profiles </td><td>unsigned int </td><td>- </td><td>0 &lt; <em>nProfiles</em> &lt; <em>nGroup</em> </td><td>no </td><td>1  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 </p><ul>
<li>
One input data stream of dimension = 2. </li>
<li>
At least two profiles are required. </li>
</ul>
<p><b> Data Structure Translation: </b><br>
 The data are split into two named output streams: </p><ul>
<li>
<em>.extr</em> = the extracted profiles. </li>
<li>
<em>.rest</em> = the original data without the extracted profiles. </li>
</ul>
<p>The dimension of each stream is 1 or 2, depending on its number of profiles.</p>
<p><b> Technical Details: </b><br>
 The filter does not work inplace.</p>
<p><b>Example: </b><br>
 </p><pre class="fragment">/// three profiles, extract one
{
  // data
  RecoParameterSource D 
  {
    dim         = 2;
    procDim     = 2;
    sizes       = {4, 3};
    dataRep     = FLOAT;
    wordSize    = 8;
    baseField   = REAL;
    data        = {1, 1, 1, 1,
                   2, 2, 2, 2,
                   3, 3, 3, 3};
  };
 
  // extract
  RecoExtractFilter EX
  {
    nProfiles = 1;
    verbose   = true;
  };
 
  // output
  RecoPrintFilter P1;
  RecoPrintFilter P2;
  RecoDummySink S1;
  RecoDummySink S2;
   
  D-&gt;EX;
  EX.extr-&gt;P1;
  EX.rest-&gt;P2;
  P1-&gt;S1;
  P2-&gt;S2;
}
// result
//
// extr
// -------------------------------------------
// [1.00000e+00] [1.00000e+00] [1.00000e+00] [1.00000e+00] 
// -------------------------------------------
// rest
// -------------------------------------------
// [2.00000e+00] [2.00000e+00] [2.00000e+00] [2.00000e+00] 
// -------------------------------------------
// rest
// -------------------------------------------
// [3.00000e+00] [3.00000e+00] [3.00000e+00] [3.00000e+00] 
// -------------------------------------------</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoFidCorrFilter"></a>
RecoFidCorrFilter</h1>
<p>Performs profile correction of FID data. This filter applies 
corrections to 1D projection data reconstructed from FID acquisitions.</p>
<p>Corrections can be applied for the following effects:</p><ul>
<li>RF excitation profile of hard pulse</li>
<li>frequency response of bandwidth filter</li>
</ul>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit</th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>pulse </td><td>hard pulse duration </td><td>double </td><td>over-dwells </td><td>&gt;= 0<br>
 0 = no pulse correction </td><td>no </td><td>0  </td></tr>
<tr>
<td>order </td><td>order of sinc-shaped digital filter as applied by receiver </td><td>unsigned int </td><td>power </td><td>&gt;= 0<br>
 0 = no response correction </td><td>no </td><td>0  </td></tr>
<tr>
<td>over </td><td>oversampling applied during acquisition </td><td>unsigned int </td><td>factor </td><td>&gt; 0 </td><td>no </td><td>1  </td></tr>
<tr>
<td>origin </td><td>position of spatial origin in window </td><td>unsigned int </td><td>- </td><td>0 = left<br>
 1 = center </td><td>no </td><td>1  </td></tr>
</tbody></table>
<p><b> Connectors:</b><br>
 One input data stream is expected, which is a series of 1D projection images.</p>
<p><b> Technical Details:</b><br>
 The filter does not work inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">/// digital filter and RF pulse with shift
{
  // constant projection
  RecoDummySource Q
  {
    dim       = 1;
    procDim   = 1;
    dataRep   = FLOAT;
    baseField = REAL;
    wordSize  = 8;
    sizes     = {10};
    constant  = true;
    offset    = 1;
  };
  
  RecoFidCorrFilter C
  {
    pulse  = 0.5;
    order  = 3;
    over   = 4;
    origin = 0;
  };
  
  RecoPrintFilter P { format = "%.3e" };
  
  RecoDummySink S;
  
  Q-&gt;C; C-&gt;P; P-&gt;S;
}
// result
// [1.000e+00] [1.003e+00] [1.013e+00] [1.031e+00] [1.055e+00] [1.088e+00] [1.055e+00] [1.031e+00] [1.013e+00] [1.003e+00]</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoFileSink"></a>
RecoFileSink</h1>
<p>Writes data stream into file. The file sink writes data into a file. 
The file is identified by a filename, which is either relative to the 
current directory or a global filename (starting with "/"). Options are 
provided to create the different file formats supported by ParaVision. 
The shuffle parameter controls whether real and imaginary parts are 
stored interleaved or in different sections of the file (image data). If
 the parameter numChans is given a value &gt; 1, then the file is 
divided into numChans sections which contain data as typically 
associated to separate coil images. <br>
 </p><div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/FileSink.png" alt="FileSink.png">
<div class="caption">
File structure</div></div>
<p> If the writePars flag is set, visu (and reco) parameter files 
associated to the data set will be written into the procno directory. <br>
</p>
<p><b> Parameters: </b><br>
</p>
<table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>filename </td><td>Name of the output file. As output directory, the 
procno directory is used, if a there is a parameter set associated to 
the file sink and if the filename does not start with a /. </td><td>string </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>shuffle </td><td>Flag to determine whether complex data points will 
be stored shuffled (real and imaginary data) or in separate sections of 
the file.  </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>true  </td></tr>
<tr>
<td>numChans </td><td>Number of channels. If numChan &gt; 1, data 
arriving from multiple channels will be stored in separate compartments 
of the file. This is to allow easier visu description for multi-channel 
coil image output data. </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;NRCU </td><td>no </td><td>1  </td></tr>
<tr>
<td>writePars </td><td>Flag to control creation of visu and reco 
parameter files. Files written with this parameter set to true can be 
read by ParaVision. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>writeProcno </td><td>Write the binary data (2dseq) and visu 
parameter file into the procno path specified. As opposed to writePars, 
this option does not invoke a default Visu derivation, but derives the 
Visu parameters purely from the data descriptor entering the 
RecoFileSink. </td><td>string </td><td>none </td><td>- </td><td>no </td><td>empty  </td></tr>
<tr>
<td>procnoTypeId </td><td>specify VisuSeriesTypeId to be written. Only effective together with writeProcno </td><td>string </td><td>none </td><td>- </td><td>no </td><td>DERIVED_OTHER  </td></tr>
<tr>
<td>procnoComment </td><td>specify VisuSeriesComment to be written. Only effective together with writeProcno. </td><td>string </td><td>none </td><td>- </td><td>no </td><td>empty  </td></tr>
<tr>
<td>procnoUnits </td><td>specify VisuCoreDataUnits to be written. Must be a UCUM compliant string. Only effective together with writeProcno. </td><td>string </td><td>none </td><td>- </td><td>no </td><td>empty  </td></tr>
<tr>
<td>append </td><td>Output will be appended to an existing file rather than clearing it. This option is not compatible with the shuffle option. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>no  </td></tr>
</tbody></table>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={4};wordSize=1;dataRep=UNSIGNED;baseField=REAL;
                     data={82,69,67,79};};
   RecoPrintFilter P;
   RecoFileSink S{filename="/tmp/reco";};
   Q-&gt;P-&gt;S;
}
// result:
// [82] [69] [67] [79]
//
// (this is "R" "E" "C" "O" in ASCII code)
//
// cat /tmp/reco: 
// RECO </pre><p><br>
</p>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoFileSource"></a>
RecoFileSource</h1>
<p>Source to read data from file into stream. The file source is 
designed to read data files in the various formats provided by 
ParaVision. This includes storage of complex raw data in shuffled or 
unshuffled mode, support for different byte orders and word sizes.<br>
 The Description for the data stream can either be read from default 
parameter groups (ACQP/RECO) to read default files (fid/ser/2dseq) or 
from the parameters.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>filename </td><td>Name of file to be read. This may be a filename 
relative to the current directory or an absolute file path. If data 
description is derived from PARX parameters, the filename defaults to 
fid resp 2dseq in the associated data set. </td><td>string </td><td>none </td><td>- </td><td>no, if initFromReco, initFromAQCP or readProcno is set </td><td>fid/ser/2dseq if defined from ACQP or RECO  </td></tr>
<tr>
<td>contData </td><td>Flag to distinguish K-Block and continuous data. 
In K-Block format blocks in the first direction are padded with 0 values
 to fit into 1024 byte blocks. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>true  </td></tr>
<tr>
<td>asciiMode </td><td>Flag to determine that data is read from a (whitespace separated) Text file. Complex data must be shuffled in this case. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>repeatMode </td><td>Flag to determine that the output data is 
replicated for each repetition of the input data (nr Parameter). Thus 
the input file contains data only for one single repetition! </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>numChan </td><td>number of Channels: in case of multi channel data 
sets, multi repetition data is stored as the second outmost dimension 
though it is created earlier. For this reason the number of channels 
must be dealt separately. </td><td>int </td><td>none </td><td>&gt;=1 </td><td>no </td><td>1  </td></tr>
<tr>
<td>readProcno </td><td>initialize the data descriptor from the visu parameters of the given procno path, and read the corresponding 2dseq file </td><td>string </td><td>none </td><td>- </td><td>no </td><td>empty  </td></tr>
<tr>
<td>procDimAllFrames </td><td>For "readProcno" operation, set the 
processing dimension of the data descriptor such that all frames are 
included in a procDim block.  </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td><p class="starttd">false </p>
<p class="endtd"></p>
</td></tr>
</tbody></table>
<p>In addition to these parameters, parameters listed under <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#DataDescriptor">DataDescriptor</a> can be specified.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   // file /tmp/x containing 10 2 1 4
   RecoFileSource Q{dim=2;sizes={2,2};baseField=REAL;dataRep=SIGNED;wordSize=2;
                    asciiMode=true;filename="/tmp/x";procDim=1};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;P-&gt;S;
}
// result:
// [10] [2] [1] [4] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoFlowFilter"></a>
RecoFlowFilter</h1>
<p>Performs data combination for velocity mapping. The flow filter 
combines four inputs, hereafter called A, B, C, and D, calculating four 
outputs, called v(x), v(y), v(z) and static, in the following way: <br>
 </p><pre class="fragment">     v(x) = conj(A) * B * C * conj(D)
     v(y) = conj(A) * B * conj(C) * D
     v(z) = conj(A) * conj(B) * C * D
     static = A * B * C * D </pre><p><b>Parameters: </b><br>
 none.</p>
<p><b> Connectors: </b><br>
 The connectors are not named, but are assigned to the input and output variables in the order of connection, i.e.: </p><ul>
<li>
IN[0] = A, IN[1] = B, IN[2] = C, IN[3] = D </li>
<li>
OUT[0] = v(x), OUT[1] = v(y), OUT[2] = v(z) and OUT[3] = static </li>
</ul>
<p><b> Data Stream Requirements:</b><br>
 The filter works on complex, double precision floating point data only. <br>
 All four input streams must have the same sizes.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q1 {dim=1;sizes={2};dataRep=FLOAT;baseField=COMPLEX;
                       wordSize=8; data = { 1, 0, 0, 1}};
   RecoDummySource Q2 {dim=1;sizes={2};dataRep=FLOAT;baseField=COMPLEX;
                       wordSize=8; data = { 0, 1, -1, 0}};
   RecoDummySource Q3 {dim=1;sizes={2};dataRep=FLOAT;baseField=COMPLEX;
                       wordSize=8; data = { -1, 0, 1, 0}};
   RecoDummySource Q4 {dim=1;sizes={2};dataRep=FLOAT;baseField=COMPLEX;
                       wordSize=8; data = {  0, -1, 0, -1}};
   RecoFlowFilter F;
   RecoPrintFilter P1;
   RecoPrintFilter P2;
   RecoPrintFilter P3;
   RecoPrintFilter P4;
   RecoDummySink S1;
   RecoDummySink S2;
   RecoDummySink S3;
   RecoDummySink S4;
   Q1-&gt;F; Q2-&gt;F; Q3-&gt;F; Q4-&gt;F;
   F-&gt;P1-&gt;S1; F-&gt;P2-&gt;S2; F-&gt;P3-&gt;S3; F-&gt;P4-&gt;S4;
}
// result:
// [1.00000e+00 + i-0.00000e+00] [-1.00000e+00 + i0.00000e+00]
// [-1.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00]
// [1.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00]
// [-1.00000e+00 + i0.00000e+00] [-1.00000e+00 + i0.00000e+00] </pre><p><br>
</p>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoFrqOffsetFilter"></a>
RecoFrqOffsetFilter</h1>
<p>Calculates frequency offsets from complex spectra. The actual 
frequency offset of each spectrum is calculated from the position of the
 maximum peak of the magnitude spectrum. A lineform analysis is 
performed that delivers the peak width (after phase correction of 
complex spectrum) for a given level (default 50%). In case of multiple 
receive channels the effective frequency offset is calculated as 
(weighted) average of all channels. For multiple channels and multiple 
spectra data blocks of channels are expected in the inner loop of the 
dataflow. In each repetition nspec * nchan data are expected. If 
magnitude spectra are analyzed, the linewidth of the corresponding real 
valued spectrum can be estimated, assuming Lorentzian line shapes.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>nchan  </td><td>Number of active receive channels.  </td><td>int  </td><td>none  </td><td>&gt;0  </td><td>yes  </td><td>1   </td></tr>
<tr>
<td>nspec  </td><td>Number of spectra per repetition  </td><td>int  </td><td>none  </td><td>&gt;0  </td><td>no  </td><td>1   </td></tr>
<tr>
<td>nnoisep  </td><td>Number of points used to identify noise level.  </td><td>int  </td><td>none  </td><td>&gt;2  </td><td>no  </td><td>100   </td></tr>
<tr>
<td>swh  </td><td>Spectrum width.  </td><td>double  </td><td>Hz  </td><td>&gt;20  </td><td>yes  </td><td>none   </td></tr>
<tr>
<td>applyPhase  </td><td>Flag to transfer phase correction to data. </td><td>bool  </td><td>none  </td><td>true/false  </td><td>no  </td><td>false   </td></tr>
<tr>
<td>estLorentzPw  </td><td>Flag to estimate Lorentz peak width from magnitude spectrum. </td><td>bool  </td><td>none  </td><td>true/false  </td><td>no  </td><td>false   </td></tr>
<tr>
<td>pwl  </td><td>Peak width level.  </td><td>double array  </td><td>% of max peak  </td><td>[1,99]  </td><td>no  </td><td>{ 50 }   </td></tr>
<tr>
<td>pwch  </td><td>Peak width per channel.  </td><td>double array [npwl][nspec][nchan]  </td><td>Hz  </td><td>&gt;0  </td><td>no  </td><td>none   </td></tr>
<tr>
<td>wpw  </td><td>Weighted average peak width.  </td><td>double array [npwl][nspec]  </td><td>Hz  </td><td>&gt;0  </td><td>no  </td><td>no   </td></tr>
<tr>
<td>weigths  </td><td>Channel specific weights.  </td><td>double array [nspec][nchan]  </td><td>no  </td><td>&gt;= 0.0  </td><td>no  </td><td>1.0   </td></tr>
<tr>
<td>chfrqoffs  </td><td>Frequency offsets of max peak. </td><td>double array [nspec][nchan]  </td><td>Hz  </td><td>+- swh/2  </td><td>no  </td><td>no   </td></tr>
<tr>
<td>wafrqoffs  </td><td>Channel weighted averaged Frequency offsets. </td><td>double array [nspec]  </td><td>Hz  </td><td>+- swh/2  </td><td>yes  </td><td>no   </td></tr>
<tr>
<td>peak  </td><td>Amplitude of max peak.  </td><td>double array [nspec][nchan]  </td><td>none  </td><td>&gt;=0  </td><td>no  </td><td>no   </td></tr>
<tr>
<td>noise  </td><td>Noise level.  </td><td>double array [nxpec][nchan]  </td><td>none  </td><td>none  </td><td>no  </td><td>no   </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 The filter can operate in-place.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{

}
// result:
// </pre><p> <br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoFTFilter"></a>
RecoFTFilter</h1>
<p>Performs Fourier transformation in a single spatial direction. The 
filter performs a discrete forward (parameter exponent = -1) or inverse 
(exponent = 1) Fourier transformation in a given spatial direction 
(parameter direction) on complex data. In the forward transformation, a 
time domain vector f of length n is transformed into a frequency domain 
vector F (indices k and j running from 1&nbsp;...&nbsp;n):</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ F(j) = \sum_{k=1}^n f(k) \exp(- 2\pi i (k-1)(j-1)) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_18.png">
</p>
<p>In the inverse transformation, a frequency domain vector F is 
transformed into a time domain vector f (indices k and j running from 
1&nbsp;...&nbsp;n):</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(k) = \frac{1}{n} \sum_{j=1}^n F(j) \exp(+ 2\pi i (j-1)(k-1)) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_19.png">
</p>
<p>By convention, the normalization to the vector length n is carried out during the inverse Fourier transformation.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>direction </td><td>direction in which 1D Fourier transform is performed </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;dim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>exponent </td><td>Exponent to distinguish between forward (-1) and inverse (+1) Fourier transform </td><td>int </td><td>none </td><td>-1,1 </td><td>no </td><td>-1  </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 The filter can work in place.</p>
<p><b> Data Stream Requirements:</b><br>
 The filter is implemented for complex floating point data only. The procDim must match the direction of the transformation.<br>
</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={4};baseField=COMPLEX;wordSize=8;dataRep=FLOAT;
                     data = {1,0,0,0,-1,0,0,0}};
   RecoFTFilter    FT;
   RecoPrintFilter P1{rowsize=2;format="%4.1f";}; 
   RecoFTFilter    IFT{exponent=1}; 
   RecoPrintFilter P2{rowsize=2;format="%4.1f";};
   RecoDummySink S;

   Q-&gt;FT-&gt;P1-&gt;IFT-&gt;P2-&gt;S;
}
// result:
// -------------------------------------------
// [ 0.0 + i 0.0] [ 2.0 + i 0.0] 
// [ 0.0 + i 0.0] [ 2.0 + i 0.0] 
// -------------------------------------------
// -------------------------------------------
// [ 1.0 + i 0.0] [ 0.0 + i 0.0] 
// [-1.0 + i 0.0] [ 0.0 + i 0.0] 
// -------------------------------------------
</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoFTShiftFilter"></a>
RecoFTShiftFilter</h1>
<p>Modulates complex data with a phase ramp. The FT shift filter 
modulates complex data with a phase ramp to generate a shift in the 
associated Fourier domain, according to the correspondence: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ FT[ f(x-x_0) ] = FT[ f(x) ] \exp(-i k x_0) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_20.png">
</p>
<p> The actual shift will thus only be effective, if the FT shift filter is followed by a FT filter. The parameter <em>shift</em>
 is defined in the image domain, it can be specified separately for each
 frame and is given as a relative shift ranging from 0 to 1, where 0.5 
corresponds to a (right) shift of half the image width.<br>
</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>winDirection </td><td>direction in which the shift is effective. </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;frameDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>frameDim </td><td>dimensionality of a single frame - by default derived from the input data descriptor </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;dim </td><td>no </td><td>data descriptor frameDim  </td></tr>
<tr>
<td>frameSize </td><td>number of consecutive frames to be treated with the same shift </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;total nr of frames </td><td>no </td><td>total nr of frames  </td></tr>
<tr>
<td>shift </td><td>relative shift, effective after following FT </td><td>double[NI] </td><td>none </td><td>0&nbsp;...&nbsp;1.0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>exponent </td><td>exponent of the following FT (determines direction of shift) </td><td>integer </td><td>none </td><td>-1: apply <em>shift</em> as is<br>
 +1: apply 1 - <em>shift</em>  </td><td>no </td><td>-1  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The filter works on floating point data only. The procDim must match the winDirection. <br>
</p>
<p><b> Data Stream Translations:</b><br>
 The output data will always be complex.<br>
</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={4};dataRep=FLOAT;wordsize=8;baseField=REAL;};
   RecoFTShiftFilter F{shift={0.5}};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;F-&gt;P-&gt;S;
}
// result:
// [0.00000e+00 + i0.00000e+00] [-1.00000e+00 + i1.22461e-16]
// [2.00000e+00 - i4.89843e-16] [-3.00000e+00 + i1.10215e-15] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoGaussWinMultFilter"></a>
RecoGaussWinMultFilter</h1>
<p>Multiplies data with a Gaussian window function. The Gaussian window function <img class="formulaInl" alt="$ f(t) $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_21.png"> is described by three parameters <b>delta</b>, <b>tau</b> and <b>gamma</b>, according to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(t) = \exp\left(-\delta t - \tau t^2 - \gamma\right)\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_22.png">
</p>
<p>With <img class="formulaInl" alt="$ \gamma=0 $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_23.png">
 (default), this description corresponds to the combination of an 
exponential decay with a centered Gauss curve and can be rewritten as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \exp\left(-\tau \left(t + \frac{\delta}{2 \tau}\right)^2 + \frac{\delta^2}{4 \tau}\right) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_24.png">
</p>
<p>which means, that the function is stretched horizontally by the factor <img class="formulaInl" alt="$\tau$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_25.png">, shifted by <img class="formulaInl" alt="$-\delta / 2 \tau $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_26.png"> and stretched vertically by <img class="formulaInl" alt="$ \exp(\delta ^ 2 / (4 \tau))$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_27.png">. The domain for the window function with this parametrization is <img class="formulaInl" alt="$[0,1]$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_28.png">.</p>
<div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/RecoGaussWin.png" alt="RecoGaussWin.png">
<div class="caption">
Gauss curve</div></div>
<p> In terms of topspin parameters GB, LB and SWH, delta and tau can be expressed as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\delta = \pi * {\rm LB}\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_29.png">
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[\tau = - \delta / ( 2 * {\rm GB} * N / {\rm SWH})\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_30.png">
</p>
<p> In this setting, GB defines the position (ranging from 0 to 1) 
within the acquisition window and LB compensates for the T2 decay - so a
 Gaussian line shape will be achieved when <img class="formulaInl" alt="$ {\rm LB} = - 1 / (\pi * T2). $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_31.png">.</p>
<p>For imaging applications such as low-pass filtering, it is often 
required to place a unit-height Gaussian of a given width 2a at a given 
position t0 in the window <img class="formulaInl" alt="$[0,1]$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_28.png">:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\exp\left(-\left((t-t0)/a\right)^2\right)\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_32.png">
</p>
<p>In terms of parameters a and t0, the filter parameters can be expressed as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\tau = 1/a^2\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_33.png">
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[\delta = -2*t0/a^2\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_34.png">
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[\gamma = (t0/a)^2.\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_35.png">
</p>
<p> Omitting gamma (which is not directly relevant for filter 
properties) may lead do digital precision problems for narrow Gaussians 
shifted far from t=0.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>winDirection </td><td>Direction for filter execution </td><td>init </td><td>none </td><td>0&nbsp;...&nbsp;procDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>delta </td><td></td><td>double </td><td>none </td><td>- </td><td>no, if LB/GB/SW set  </td><td>-  </td></tr>
<tr>
<td>tau </td><td></td><td>double </td><td>none </td><td>- </td><td>no, if LB/GB/SW set </td><td>-  </td></tr>
<tr>
<td>gamma </td><td></td><td>double </td><td>none </td><td>- </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>LB </td><td>line broadening factor </td><td>double </td><td>Hertz </td><td>- </td><td>no, if delta/tau set </td><td>-  </td></tr>
<tr>
<td>GB </td><td>Gauss broadening </td><td>double </td><td>none </td><td>- </td><td>no, if delta/tau set </td><td>-  </td></tr>
<tr>
<td>SW </td><td>sweep width  </td><td>double </td><td>Hertz </td><td>- </td><td>no, if delta/tau set </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 Window multiplication is implemented for floating point input streams 
only. The window direction must fit within the selected processing 
dimension.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={6};wordSize=8;dataRep=FLOAT;baseField=REAL;
                     constant=true;offset = 1};
   RecoGaussWinMultFilter W{delta = -1.0; tau = 1.0};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;W-&gt;P-&gt;S;
}
// result:
// [1.00000e+00] [1.14900e+00] [1.24885e+00] [1.28403e+00] [1.24885e+00] [1.14900e+00]</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoHalfFourierFilter"></a>
RecoHalfFourierFilter</h1>
<p>Performs Fourier transformation in a single spatial direction of 
asymmetrically reduced data. A homodyne half-Fourier reconstruction is 
used.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>echoPosition </td><td>position of the echo (distance of k-space center from the first sample) </td><td>double </td><td>grid points </td><td>&gt;= 0 </td><td>no </td><td>RECO_ft_size[direction] / 2  </td></tr>
<tr>
<td>direction </td><td>direction in which 1D Fourier transform is performed </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;dim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>exponent </td><td>exponent to distinguish between forward (-1) and inverse (+1) Fourier transform </td><td>int </td><td>none </td><td>-1, 1 </td><td>no </td><td>-1  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 Shuffled complex, double precision floating point data of any dimension.<br>
 <b> Data Structure Translation: </b><br>
 The output data is of identical structure and size as the input data.<br>
 <b> Technical Details: </b><br>
 The filter does work inplace. <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoHistogramFilter"></a>
RecoHistogramFilter</h1>
<p>Detects lower and upper quantiles of input values on a per-repetition
 basis. The histogram filter scans through input data to detect the 
lower and upper quantiles of the input values for each repetition. Here,
 real and complex data are not distinguished. The filter requires that 
arrays map_min and map_max are defined. The size of these arrays has to 
be equal or greater than the total number of repetitions.</p>
<p>The filter sets up a histogram of the input data for each repetition.
 The range of the histogram is derived from the map_min and map_max 
parameters of all frames belonging to the current repetition. Outliers 
are counted and can be output in verbose mode. The filter computes the 
lower and upper quantiles for each repetition. To this end, first the 
normalized cumulative histogram is computed. Then, the filter scans 
through the cumulative histogram and uses the lower and upper quantile 
parameters as thresholds. From the computed indices, the lower and upper
 quantiles are derived and written to the parameter arrays map_min, 
map_max where the size of these arrays is not modified, i.e. the arrays 
will contain constant entries per repetition if there are multiple 
frames in each repetition. Note, that the quantiles are discrete and 
rounded to the grid of the histogram, which is determined by the 
parameter nrBins and the map_min / map_max input parameters.<br>
</p>
<div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/histogram.png" alt="histogram.png">
<div class="caption">
histogram, cumulative histogram and the parameters of the histogram filter</div></div>
<p> <b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>lowerQuantilParameter </td><td>Fraction of low value data points to be ignored in percent. </td><td>double </td><td>none </td><td>0-upperQuantilParameter </td><td>no </td><td>20  </td></tr>
<tr>
<td>upperQuantilParameter </td><td>Fraction of high value data points to be ignored in percent. </td><td>double </td><td>none </td><td>lowerQuantilParameter-100 </td><td>no </td><td>80  </td></tr>
<tr>
<td>nrBins </td><td>Number of bins used to setup the histogram. </td><td>unsigned int </td><td>none </td><td>&gt; 0 </td><td>no </td><td>1000  </td></tr>
<tr>
<td>map_min </td><td>(input/output parameter) As input parameter, the 
minima of frames are specified. As output parameter, the lower quantiles
 are returned. This parameter is usually aliased to RECO_map_min. For 
each frame, a different entry is used. In setup mode only the first 
repetition is used. </td><td>double[] </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>map_max </td><td>(input/output parameter) As input parameter, the 
maxima of frames are specified. As output parameter, the upper quantiles
 are returned. This is usually aliased to RECO_map_max. For each frame, a
 different entry is used. In setup mode only the first repetition is 
used. </td><td>double[] </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The filter works for floating point data only.<br>
</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
    map_min={0,10,22,30}; map_max={9,18,29,39};
    RecoDummySource Q {wordSize=8;dataRep=FLOAT;baseField=REAL;dim=2;nr=2;frameDim=1;procDim=1;sizes={10,2}};
    RecoPrintFilter P {format="%2.0f"};
    RecoHistogramFilter H{nrOfBins=1000;verbose=true;
                          lowerQuantilParameter=10;
                          upperQuantilParameter=90;};
    RecoDummySink S;

    Q-&gt;P-&gt;H-&gt;S;

}
// result:
//
// -------------------------------------------
// [ 0] [ 1] [ 2] [ 3] [ 4] [ 5] [ 6] [ 7] [ 8] [ 9] 
// -------------------------------------------
// -------------------------------------------
// [10] [11] [12] [13] [14] [15] [16] [17] [18] [19] 
// -------------------------------------------
// current repetition=0,  number of lower outliers=0,  number of upper outliers=1
// lowerQuantil[0]=1.989,  upperQuantil[0]=15.993
// lowerQuantil[1]=0,  upperQuantil[1]=0
// -------------------------------------------
// [20] [21] [22] [23] [24] [25] [26] [27] [28] [29] 
// -------------------------------------------
// -------------------------------------------
// [30] [31] [32] [33] [34] [35] [36] [37] [38] [39] 
// -------------------------------------------
// current repetition=1,  number of lower outliers=2,  number of upper outliers=1
// lowerQuantil[0]=1.989,  upperQuantil[0]=15.993
// lowerQuantil[1]=23.9805,  upperQuantil[1]=37.0025</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoInverseFidFilter"></a>
RecoInverseFidFilter</h1>
<p>Algebraic 1D image reconstruction of data acquired with an FID imaging method. <b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit</th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>sampOver </td><td>oversampling factor of data acquisition </td><td>unsigned int </td><td>- </td><td>&gt; 0 </td><td>no </td><td>1  </td></tr>
<tr>
<td>sampFid </td><td>number of samples per FID </td><td>unsigned int </td><td>oversampled points </td><td>&gt; 0 </td><td>no </td><td>recoN * sampOver / 2  </td></tr>
<tr>
<td>recoN </td><td>size of reconstructed image (excluding oversampling) </td><td>unsigned int </td><td>pixels </td><td>&gt;= 2, even </td><td>yes </td><td>-  </td></tr>
<tr>
<td>recoOver </td><td>oversampling factor of reconstruction </td><td>unsigned int </td><td>- </td><td>&gt; 0 </td><td>no </td><td>1  </td></tr>
<tr>
<td>recoRegularise </td><td>regularisation of inversion </td><td>double </td><td>condition number </td><td>&gt;= 0, else machine precision is used </td><td>no </td><td>1e-10  </td></tr>
<tr>
<td>recoT2 </td><td>T2 value used for exponential filtering </td><td>double </td><td>FID size </td><td>&gt; 0, else no filtering </td><td>no </td><td>0  </td></tr>
<tr>
<td>recoPhc0 </td><td>zero order phase correction<br>
 phase at k = 0 </td><td>double </td><td>rad </td><td>any </td><td>no </td><td>0  </td></tr>
<tr>
<td>recoAmp0 </td><td>amplitude at k = 0<br>
 improves reconstruction<br>
 only used if <em>recoPhc0</em> is available </td><td>double </td><td>as data </td><td>&gt;= 0 </td><td>no </td><td>not used  </td></tr>
<tr>
<td>recoScaleAmp0 </td><td>correction factor for amplitude at k = 0<br>
 corrects for background-related errors<br>
 only effective together with <em>recoAmp0</em> </td><td>double </td><td>- </td><td>&gt; 0 </td><td>no </td><td>1.0  </td></tr>
<tr>
<td>recoFTExp </td><td>exponent of Fourier transform from space to k-space </td><td>integer </td><td>- </td><td>-1 = FT<br>
 +1 = IFT </td><td>no </td><td>-1  </td></tr>
<tr>
<td>recoFTShift </td><td>apply FT shift to image </td><td>bool </td><td>- </td><td>true = real space is centered in image<br>
 false = real space center is at left image corner </td><td>no </td><td>false  </td></tr>
<tr>
<td>groupDelay </td><td>group delay of digital filter </td><td>double </td><td>points </td><td>&gt;= 0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>filterDelay </td><td>delay of analog filter </td><td>double </td><td>points </td><td>&gt;= 0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>acqDelay </td><td>delay of acquisition due to pulse duration and T/R switching (see below) </td><td>double </td><td>points </td><td>&gt;= 0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>skipData </td><td>data to be skipped additionally at beginning of FID </td><td>unsigned int </td><td>points </td><td>&gt;= 0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>halfAcq </td><td>determines if one or two FIDs were acquired </td><td>bool </td><td>- </td><td>true = one FID<br>
 false = two FIDs with opposite gradient </td><td>no </td><td>false  </td></tr>
</tbody></table>
<p><b> Connectors: </b><br>
 One or two FIDs required for a reconstruction are assembled in one input data vector.</p>
<p><b> Data Stream Requirements:</b><br>
 The input data must be complex, floating point, and of dimension &gt;= 1.</p>
<p><b> Data Structure Translation: </b><br>
</p><ul>
<li>The output per reconstruction is a 1D profile in real space of the desired size.</li>
<li>The output data is complex, floating point, and of dimension &gt;= 1.</li>
</ul>
<p><b> Technical Details: </b><br>
 The filter does not work inplace.</p>
<p>The timing of signal excitation and acquisition is illustrated below,
 showing the filter-internal calculation of the times of the acquired 
points as well as the appropriate setting of the input parameter <em>acqDelay</em>. </p><div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/FID_timing.png" alt="FID_timing.png">
</div>
<pre class="fragment">&lt;b&gt; Example: &lt;/b&gt;&lt;br&gt; 
</pre> <pre class="fragment">/// 2 FID
{
  // read data from file
  RecoFileSource D
  {
    filename="fid.dat";
    dim             = 1;
    procDim         = 1;
    sizes           = 64;
    dataRep         = FLOAT;
    wordSize        = 8;
    baseField       = COMPLEX;
  };
 
  // reconstruct
  RecoInverseFidFilter I
  {
    recoN           = 64;
    recoRegularise  = 0.01;
    recoFTShift     = true;
    halfAcq         = false;
  };
 
  // output
  RecoPrintFilter P;
  RecoDummySink S;
   
  D-&gt;I; I-&gt;P; P-&gt;S;
}</pre><p>The filter is an implementation of the RecoInverseFilterBase:<br>
<br>
<br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoMagnitudeFilter"></a>
RecoMagnitudeFilter</h1>
<p>Calculates the magnitude of a real or complex floating point data 
stream. The magnitude filter calculates the absolute value of the input 
data. For real values <img class="formulaInl" alt="$x$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_4.png">, the filter returns <img class="formulaInl" alt="$ |x| $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_36.png">, for complex values <img class="formulaInl" alt="$z = a+i b$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_37.png">, the result is <img class="formulaInl" alt="$ |z| = \sqrt{z \bar z} = \sqrt{a^2+b^2}$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_38.png">.</p>
<p><b>Parameters: </b><br>
 none.</p>
<p><b> Data Stream Requirements:</b><br>
 The filter can handle floating point data only. <br>
</p>
<p><b> Data Structure Translation: </b><br>
 Output data is always real<br>
</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={2};dataRep=FLOAT;};
   RecoPrintFilter P1;
   RecoMagnitudeFilter M;
   RecoPrintFilter P2;
   RecoDummySink S;
   Q-&gt;P1-&gt;M-&gt;P2-&gt;S;
}
// result:
// [0.00000e+00 + i1.00000e+00][2.00000e+00 + i3.00000e+00]
// [1.00000e+00][3.60555e+00]</pre> <pre class="fragment">&lt;b&gt; References: &lt;/b&gt;&lt;br&gt;
  man 3 hypot, man 3 fabs &lt;br&gt;</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoMapFilter"></a>
RecoMapFilter</h1>
<p>Performs mapping of image values into a specified range. The map 
filter is designed to be used for mapping of data into a previously 
specified range. It multiplies the values of incoming image objects 
(frames), <img class="formulaInl" alt="$ x $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_39.png">,
 with a real value (slope) and shifts them by an offset, which can be 
specified or calculated for each frame separately. Thus, the values of 
the output frames, <img class="formulaInl" alt="$ y $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_40.png">, read </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x \rightarrow y = {\rm slope}\;x - {\rm offset} \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_41.png">
</p>
<p>There are two ways to determine which slope and offset are used: Either they can be specified directly by setting the parameters</p><ul>
<li>defaultSlope</li>
<li>defaultOffset</li>
</ul>
<p>In this case all frames will be mapped using these predefined values.</p>
<p>Alternatively, a target mapping range can be defined, by passing the parameters</p><ul>
<li>rangeMin</li>
<li>rangeMax</li>
<li>map_min</li>
<li>map_max</li>
</ul>
<p>The map_min and map_max values are defined for each frame separately 
and contain those values of each frame, that should be mapped onto the 
values rangeMin and rangeMax, respectively. Slope and offset are thus 
calculated such that</p>
<p>map_min <img class="formulaInl" alt="$ \rightarrow $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_42.png"> rangeMin<br>
 map_max <img class="formulaInl" alt="$ \rightarrow $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_42.png"> rangeMin</p>
<p>If map_min and map_max are determined by <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMinMaxFilter">RecoMinMaxFilter</a>, they are actually equal to the minimum and maximum value of each frame. In contrast, if map_min and map_max are determined by <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMinMaxFilter">RecoMinMaxFilter</a> in histogram mode, or by <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoHistogramFilter">RecoHistogramFilter</a>,
 the map_min value can be larger than the minimum frame value and the 
map_max value can be smaller than the maximum frame value. Still, these 
are mapped to rangeMin and rangeMax, respectively, and some values are 
mapped outside the specified range. This situation is called overflow.</p>
<p>The filter functionality can be further controlled by the following flags:</p><ul>
<li>symmetricMode: Always preserve the origin (position of zero value), 
i.e. fix offset=0. In this case, generally only one of the mapping 
targets, map_min&nbsp; <img class="formulaInl" alt="$ \rightarrow $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_42.png">&nbsp;rangeMin and map_max&nbsp; <img class="formulaInl" alt="$ \rightarrow $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_42.png">&nbsp;rangeMax, can be fulfilled, namely the mapping where the range parameter has the larger absolute value.</li>
<li>cutoffMode: In an overflow situation, map values below rangeMin to 
rangeMin and values larger than rangeMax to rangeMax. Overflows may 
occur when using a histogram method for determining map_min and map_max.</li>
<li>perObjectMode: Map each frame with individual slopes and offsets.</li>
<li>perRepetitionMode: Map all frames of a repetition using a common 
slope and offset. In this case, the minimum of all map_min values of a 
given repetition is mapped to rangeMin, and the maximum of the map_max 
values to rangeMax.</li>
<li>initOnce: Map all frames in all repetitions using one common slope 
and offset. In this case, the minimum of map_min values and the maximum 
of map_max values of the <em>first</em> repetition is used.</li>
<li>writePars</li>
</ul>
<p>If writePars is set to true, the values used for the mapping are returned via the parameters</p><ul>
<li>slope</li>
<li>offset</li>
<li>minima (of each output frame)</li>
<li>maxima (of each output frame)</li>
<li>map_min (input values, possibly readjusted)</li>
<li>map_max (input values, possibly readjusted)</li>
</ul>
<p>These parameters are typically aliased to the corresponding 
reconstruction parameters RECO_map_slope, RECO_map_offset, RECO_minima, 
RECO_maxima, RECO_map_min, RECO_map_max, and each contain one entry per 
frame/image object.</p>
<p>The readjustment of map_min and map_max takes place such that when 
performing the inverse mapping, the value of rangeMin would be mapped to
 map_min and the value of rangeMax would be mapped to map_max. This is 
necessary, if the mapping is performed in symmetrizedMode or 
perRepetition.</p>
<p>During setup mode, i.e., when the number of repetitions is not known a priori, the mapping must be performed per repetition.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>defaultSlope </td><td>Define fixed slope for mapping function. If a 
single value is given, this is used for all frames. If an array is 
given, its length must be equal to the number of frames (including 
repetitions). If not defined, the slope will be calculated from 
rangeMin, rangeMax, map_min, and map_max. </td><td>double[] </td><td>none </td><td>- </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>defaultOffset </td><td>Define fixed offset for mapping function. If a
 single value is given, this is used for all frames. If an array is 
given, its length must be equal to the number of frames (including 
repetitions). If not defined, and if symmetricMode=false, the offset 
will be calculated together with the the slope. </td><td>double[] </td><td>none </td><td>- </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>rangeMin </td><td>Desired minimum of output data range. </td><td>double </td><td>none </td><td>- </td><td>no </td><td>-DBL_MAX  </td></tr>
<tr>
<td>rangeMax </td><td>Desired maximum of output data range. </td><td>double </td><td>none </td><td>- </td><td>no </td><td>DBL_MAX  </td></tr>
<tr>
<td>map_min </td><td>(input/output parameter) As input parameter, 
specifies the values of the incoming frames to be mapped to rangeMin. As
 output parameter, returns input map_min, readjusted for the actual 
mapping performed. Usually aliased to RECO_map_min. </td><td>double[] </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>map_max </td><td>(input/output parameter) As input parameter, 
specifies the values of the incoming frames to be mapped to rangeMax. As
 output parameter, returns input map_max, readjusted for the actual 
mapping performed. Usually aliased to RECO_map_max. </td><td>double[] </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>symmetricMode </td><td>Flag to select symmetric (linear) mapping regarding zero. This mapping results in offset=0 </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>true  </td></tr>
<tr>
<td>cutoffMode </td><td>Flag to select clipping of data. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>true  </td></tr>
<tr>
<td>perObjectMode </td><td>Flag to toggle calculation of mapping slope and offset individually for each frame. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>commonMapLoop </td><td>describes a category loop structure in which 
frames that belong to the same category receive a common mapping slope 
and offset. Format: commonMapLoop = (in,num,out), where "num" is the 
number of different categories, "in" determines the number of 
consecutive frames that are assigned to a category, before switching to 
the next category, and "out" determines the number of times the in-num 
loop is repeated. The total number of frames must be equal to 
in*num*out.  </td><td>double[3] </td><td>none </td><td>- </td><td>no </td><td>-  </td></tr>
<tr>
<td>perRepetitionMode </td><td>Flag to toggle calculation of common mapping slope and offset for all frames in a repetition. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>initOnce </td><td>Use common mapping slope and offset (calculated in
 the first repetition) for all frames in all repetitions. Used for 
absolute mapping. This flag is only considered, if 
perRepetitionMode=true. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>true  </td></tr>
<tr>
<td>commonMapLoop </td><td>describes a category loop structure in which 
frames that belong to the same category receive a common mapping slope 
and offset. Format: commonMapLoop = (in,num,out), where "num" is the 
number of different categories, "in" determines the number of 
consecutive frames that are assigned to a category, before switching to 
the next category, and "out" determines the number of times the in-num 
loop is repeated. The total number of frames must be equal to 
in*num*out.  </td><td>double[3] </td><td>none </td><td>- </td><td>no </td><td>-  </td></tr>
<tr>
<td>writePars </td><td>Flag to toggle the output of the mapping values actually used to output parameters. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>true  </td></tr>
<tr>
<td>minima </td><td>(output parameter) Returns minima of the mapped values for each output frame. Usually aliased to RECO_minima. </td><td>double[] </td><td>none </td><td>- </td><td>if&nbsp;writePars=true </td><td>-  </td></tr>
<tr>
<td>maxima </td><td>(output parameter) Returns maxima of the mapped values for each output frame. Usually aliased to RECO_maxima. </td><td>double[] </td><td>none </td><td>- </td><td>if&nbsp;writePars=true </td><td>-  </td></tr>
<tr>
<td>slope </td><td>(output parameter) Returns slope for calculated/used mapping function per frame. Usually aliased to RECO_map_slope. </td><td>double[] </td><td>none </td><td>- </td><td>if&nbsp;writePars=true </td><td>-  </td></tr>
<tr>
<td>offset </td><td>(output parameter) Returns offset for calculated/used mapping function per frame. Usually aliased to RECO_map_offset. </td><td>double[] </td><td>none </td><td>- </td><td>if&nbsp;writePars=true </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The filter is implemented for floating point data only, supporting real and complex numbers.</p>
<p><b> Technical Details: </b><br>
 The filter can operate inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">// ----  asymmetric mapping, per frame, without overflow
{
  map_min={-3,-4};
  map_max={ 1, 4};
  minima ={ 0, 0};
  maxima ={ 0, 0};
  slope  ={ 0, 0};
  offset ={ 0, 0};
  RecoDummySource Q{dim=2;sizes={3,2};baseField=REAL;wordSize=4;dataRep=FLOAT;
                    data = {1,0,-3,  -4,0,4};frameDim=1};
  RecoMapFilter M{rangeMin=-1;rangeMax=1;perObjectMode=true;symmetricMode=false;};
  RecoPrintFilter P1{format="%2.2f"};
  RecoPrintFilter P2{format="%2.2f"};
  RecoDummySink S;
  Q-&gt;P1-&gt;M-&gt;P2-&gt;S;
}
// result:
//
// [1.00] [0.00] [-3.00] 
// [1.00] [0.50] [-1.00] 
//
// [-4.00] [0.00] [4.00] 
// [-1.00] [0.00] [1.00] 
//
// slope  ={0.5,0.25}
// offset ={-0.5,0}
// minima ={-1,-1}
// maxima ={1,1} 
// map_min={-3,-4}
// map_max={1,4} 

// ---- symmetric mapping, per frame, without overflow
{
  map_min={-3,-4};
  map_max={ 1, 4};
  minima ={ 0, 0};
  maxima ={ 0, 0};
  slope  ={ 0, 0};
  offset ={ 0, 0};
  RecoDummySource Q{dim=2;sizes={3,2};baseField=REAL;wordSize=4;dataRep=FLOAT;
                    data = {1,0,-3,  -4,0,4};frameDim=1};
  RecoMapFilter M{rangeMin=-1;rangeMax=1;perObjectMode=true;symmetricMode=true;};
  RecoPrintFilter P1{format="%2.2f"};
  RecoPrintFilter P2{format="%2.2f"};
  RecoDummySink S;
  Q-&gt;P1-&gt;M-&gt;P2-&gt;S;
}
// result:
//
// [1.00] [0.00] [-3.00] 
// [0.33] [0.00] [-1.00] 
//
// [-4.00] [0.00] [4.00] 
// [-1.00] [0.00] [1.00] 
//
// slope  ={0.333,0.25}
// offset ={0,0}
// minima ={-1,-1}
// maxima ={0.333,1} 
// map_min={-3,-4}
// map_max={3,4} 

// ---- symmetric mapping, per repetition, with overflow
{
  map_min= {-1,-2,0,0};
  map_max= {1,1,100,50};
  minima = {0,0,0,0};
  maxima = {0,0,0,0};
  slope  = {0,0,0,0};
  offset = {0,0,0,0};
  RecoDummySource Q{dim=2;sizes={3,2};nr=2;baseField=REAL;wordSize=4;dataRep=FLOAT;
                    data = {1,0,-3,  1,0,-2,  0,50,100, 0,25,50};frameDim=1};
  RecoMapFilter M{rangeMin=-1;rangeMax=1;perRepetitionMode=true;initOnce=false;symmetricMode=true;cutoffMode=true;};
  RecoPrintFilter P1{format="%2.2f"};
  RecoPrintFilter P2{format="%2.2f"};
  RecoDummySink S;
  Q-&gt;P1-&gt;M-&gt;P2-&gt;S;
}
// result:
//
// [1.00] [0.00] [-3.00] 
// [0.50] [0.00] [-1.00] 
//
// [1.00] [0.00] [-2.00] 
// [0.50] [0.00] [-1.00] 
//
// [0.00] [50.00] [100.00] 
// [0.00] [0.50] [1.00] 
//
// [0.00] [25.00] [50.00] 
// [0.00] [0.25] [0.50] 
//
// slope  ={0.5,0.5,0.01,0.01}
// offset ={0,0,0,0}
// minima ={-0.5,-1,0,0}
// maxima ={0.5,0.5,1,0.5} 
// map_min={-2,-2,-100,-100}
// map_max={2,2,100,100} 
}
</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoMaskFilter"></a>
RecoMaskFilter</h1>
<p>Applies an ellipsoidal mask to 2D or 3D data. The mask filter masks 
2D data by a centered ellipse and 3D data by a centered ellipsoid with 
major axes as specified in the filter parameters. The values inside the 
ellipsoidal mask are not modified, the values outside the mask are set 
to zero.</p>
<p>Such a mask is required if, due to the sampling scheme (e.g. spiral 
or radial), the field of view is not rectangular, and the corners may 
exhibit foldover artifacts.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit</th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>sizeX </td><td>size of mask in 1st direction </td><td>unsigned int </td><td>points </td><td>&gt;= 0<br>
sizeX=0: use sizes[0] from data descriptor </td><td>no </td><td>sizes[0]  </td></tr>
<tr>
<td>sizeY </td><td>size of mask in 2nd direction </td><td>unsigned int </td><td>points </td><td>&gt;= 0<br>
sizeY=0: use sizes[1] </td><td>no </td><td>sizes[1]  </td></tr>
<tr>
<td>sizeZ </td><td>size of mask in 3rd direction </td><td>unsigned int </td><td>points </td><td>&gt;= 0<br>
sizeZ=0: use sizes[2] </td><td>no </td><td>sizes[2]  </td></tr>
</tbody></table>
<p>Note: For the 3D case "slice" means a 3D volume.</p>
<p><b> Data Stream Requirements: </b><br>
 The input data must be real or shuffled complex, double precision floating point data of dimension &gt;= 2.</p>
<p><b> Data Structure Translation: </b><br>
 The structure of input data is as follows:</p><ul>
<li>The first two or three dimensions contain the data dimensions.</li>
<li>Further dimensions hold additional slices for different locations or time points.</li>
<li>Complete slices are expected.</li>
</ul>
<p>The structure of the output data will be identical to the input data structure.</p>
<p><b> Technical Details: </b><br>
 The filter works inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">/// 2D
{
  // data
  RecoParameterSource D 
  {
    dim = 2;
    frameDim = 2;
    procDim = 2;
    sizes = {4, 4};
    dataRep = FLOAT;
    wordSize = 8;
    baseField = COMPLEX;
    data = {1,0, 1,0, 1,0, 1,0,
            1,0, 1,0, 1,0, 1,0,
            1,0, 1,0, 1,0, 1,0,
            1,0, 1,0, 1,0, 1,0};
  };
 
  // mask
  RecoMaskFilter M;
 
  // output
  RecoPrintFilter P;
  RecoDummySink S;
   
  D-&gt;M;
  M-&gt;P;
  P-&gt;S;
}
// result
// [0.00000e+00 + i0.00000e+00] [0.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00] [0.00000e+00 + i0.00000e+00]
// [0.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00]
// [1.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00]
// [0.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00] [1.00000e+00 + i0.00000e+00]</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoMeanFilter"></a>
RecoMeanFilter</h1>
<p>Computes the mean in the first dimension. The mean filter calculates 
the mean of all values in the first data dimension. It works on real and
 complex data. <br>
</p>
<p><b>Parameters:</b><br>
 none.</p>
<p><b> Data Stream Requirements:</b><br>
</p><ul>
<li>One input data stream of dimension &lt;= 2.</li>
</ul>
<p><b> Data Structure Translation: </b><br>
</p><ul>
<li>There is one output stream, with the first dimension reduced to size[0]=1, containing the mean value.</li>
</ul>
<p><b> Technical Details: </b><br>
 The filter does not work inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">// RecoStagesMean01
{
    RecoDummySource Q{
    procDim=2;wordSize=8;dataRep=FLOAT;
    baseField=REAL;dim=2;sizes={5,2};data={1,2,3,4,5,6,7,8,9,10};random=false};
    RecoPrintFilter P1{format="%4.2f";};
    RecoPrintFilter P2{format="%4.2f";};
    RecoMeanFilter M{};
    RecoDummySink S;
    Q-&gt;P1;
    P1-&gt;M;
    M-&gt;P2;
    P2-&gt;S;
}
// result
//
//-------------------------------------------
// [1.00] [2.00] [3.00] [4.00] [5.00] [6.00] [7.00] [8.00] [9.00] [10.00] 
// -------------------------------------------
// -------------------------------------------
// [3.00] [8.00] 
// -------------------------------------------</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoMethodFilter"></a>
RecoMethodFilter</h1>
<p>Allows to include freely programmable reconstruction code in a 
method. The method filter allows methods to incorporate arbitrary filter
 code for data processing during image reconstruction. For this purpose,
 the relation of a specified method parameter is called, whenever the 
processing function of the method filter is called for a block of data.</p>
<p>The data is transferred between the reconstruction process and the 
method via a shared memory buffer. The memory id of the buffer and the 
size of data to be processed are passed to the method via two method 
parameters, referenced by bufParameter and cntParameter. The dimension 
and sizes of the data must be known to the method from its own context.</p>
<p>In order to hold intermediate states, the filter can allocate 
additional memory to store context information between the calls of the 
method relation. The size of the desired memory is specified via the 
parameter contextSize, its memory id is passed back to the method via a 
method parameter, referenced by contextPointer.</p>
<p>In order to access the memory with a given memory id, the method must use a RecoGlobalMemory object. See example for details.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>dim </td><td>Dimension of the object to be transferred to the method
 processing code in each call of the relation. If set to zero, procDim 
is used. Cannot be larger than procDim. </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;procDim </td><td>yes </td><td>procDim  </td></tr>
<tr>
<td>cntParameter </td><td>(<b>output</b>) Number of bytes to be processed in the current call of the relation. Must be aliased to a method parameter. </td><td>int </td><td>bytes </td><td>&gt;=0 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>bufParameter </td><td>(<b>output</b>) Id of shared memory where data
 to be processed is located. Must be aliased to a method parameter. In 
addition, the relation of that method parameter is called each time data
 for processing is available. </td><td>int </td><td>none </td><td>&gt;=0 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>contextSize </td><td>Size of additional context memory to be allocated for this filter instance. </td><td>int </td><td>bytes </td><td>&gt;=0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>contextPointer </td><td>(<b>output</b>) Id of shared memory requested for storing context information. Must be aliased to a method parameter, if used. </td><td>int </td><td>none </td><td>&gt;=0 </td><td>no </td><td>0  </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 This filter does not operate inplace.</p>
<p><b> Data Stream Requirements:</b><br>
 The data streaming into the filter must match the interpretation of the
 data pointer obtained from RecoGlobalMemory::getAddress(), see example 
below.</p>
<p><b> Data Structure Translation: </b><br>
 The filter cannot and must not modify the structure of the data, i. e. the data dimension, sizes and base field are constant.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={4};dataRep=FLOAT;wordSize=8;baseField=REAL};
   RecoPrintFilter P;
   // method filter which adds 2 to each point
   RecoMethodFilter M{cntParameter=&lt;PvmFilterCnt&gt;;
                      bufParameter=&lt;PvmFilterBuffer&gt;};
   RecoDummySink S;
   Q-&gt;M-&gt;P-&gt;S;
}
// result:
// [2.0][3.0][4.0][5.0]

add in parsDefinition.h of the method

int parameter PvmFilterCnt;
int parameter {
   relations bufRelation;
 } PvmFilterBuffer;


Add in RecoRelatations.c

 void bufRelation()
 {
    RecoGlobalMemory M(PvmFilterBuffer);
    double* data = (double*) M.getAddress();
    int cnt  = PvmFilterCnt / sizeof(double);
    int i;
    for (i = 0; i &lt; cnt; i++)
        data[i] += 2.0;
 }
</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoSystemFilter"></a>
RecoSystemFilter</h1>
<p>Call an external program to work on the data. The RecoSystemFilter 
copies the data it receives to an exchange file and calls the external 
program specified in the parameter <code>cmd</code>. When the program has finished, its output is copied back into the reconstruction pipeline.</p>
<p>The size of the data exchanged with the external program equals one block of dimension <code>procDim</code> at the input carrier. The result of the program has to match the input size and word type.</p>
<p>If desired, the external program can write its results to a separate file, specified by the <code>resultFile</code> parameter. Otherwise the exchange file is used for input and output.</p>
<p>If a relative filename is given for <code>exchangeFile</code> or <code>resultFile</code>, it is understood to be relative to the procno directory of the current reconstruction.</p>
<p>If a command string contains the token &lt;PROCNO&gt;, this will be 
replaced with the procno directory of the current reconstruction.</p>
<p><b> Parameters: </b><br>
</p>
<table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>cmd </td><td>command string to be called </td><td>string </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>exchangeFile </td><td>name of exchange file </td><td>string </td><td>none </td><td>- </td><td>no </td><td>/tmp/exchange  </td></tr>
<tr>
<td>resultFile </td><td>name of the file where the external program saves its results. If this parameter is not set, the exchange file is used instead. </td><td>string </td><td>none </td><td>- </td><td>no </td><td>name of exchange file  </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 This filter can operate inplace.</p>
<p><b> Data Stream Requirements:</b><br>
 Any data type is supported, make sure the external program correctly interprets the binary data in the exchange file.</p>
<p><b> Data Structure Translation: </b><br>
 The filter cannot and must not modify the structure of the data, i. e. the data dimension, sizes and base field are constant.</p>
<p><b> Example: </b><br>
</p>
<p>To invert the contrast for all images, redirect the RecoUserUpdate 
relation, and after creating the default reco network, introduce the 
SystemFilter </p><pre class="fragment">RecoComputeAppendStage("PREPPASS", 0, "G", "RecoSystemFilter", "OctaveProc", "cmd=\"/tmp/PvCallOctave.sh &lt;PROCNO&gt;/infile\";exchangeFile=\"infile\";");
</pre><p> Note that the <code>cmd</code> string also contains an argument to PvCallOctave.sh specifying where the exchange file can be found.<br>
<br>
 The PvCallOctave.sh script reads </p><pre class="fragment">#!/bin/bash

unset LD_LIBRARY_PATH

octave /tmp/OctaveCallMe.m $1
</pre><p> and the octave code reads </p><pre class="fragment">% word type of reconstruction data stream
WordType = "double";

% get input file name from argument list and load its contents
exchangeFile = argv (){1};
fid = fopen(exchangeFile, "r+");
data = fread(fid, Inf, WordType);

% find maximum in current block
dataMax = max(data(:));

% invert image contrast
data = dataMax - data;

% rewind output file and overwrite with the result
frewind(fid);
fwrite(fid, data, WordType);
fclose(fid);</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoMinMaxFilter"></a>
RecoMinMaxFilter</h1>
<p>Detects minima and maxima of frames. The filter scans through input 
data to detect the minima and maxima of specific sub units. Here, real 
and complex data are not distinguished. If histogram mode is selected, 
extreme minima and maxima will not be taken into account, lower and 
upper quantile specify which portion of the data is used. Results are 
written to the parameter arrays map_min, map_max which contain one entry
 for each frame. The filter is closely connected to the <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMapFilter">RecoMapFilter</a>, which relies on the output of the MinMax filter.<br>
 The filter currently uses an exact histogram algorithm which is however
 not suited for very large datasets with large quantile portions.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>histogramMode </td><td>Select histogram mode for minima/maxima detection. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>yes  </td></tr>
<tr>
<td>lowerQuantil </td><td>Fraction of low value data points to be ignored in histogram mode. </td><td>double </td><td>none </td><td>0-upperQuantil </td><td>no </td><td>0  </td></tr>
<tr>
<td>upperQuantil </td><td>Fraction of high value data points to be ignored in histogram mode. </td><td>double </td><td>none </td><td>lowerQuantil-1 </td><td>no </td><td>1  </td></tr>
<tr>
<td>map_min </td><td>(output parameter) Returns the minima for each 
frame. This is usually aliased to RECO_map_min. In setup mode only the 
first repetition is used. </td><td>double[] </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>map_max </td><td>(output parameter) Returns the maxima for each 
frame. This is usually aliased to RECO_map_max. In setup mode only the 
first repetition is used. </td><td>double[] </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The filter works for floating point data only.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
  map_min={0,0};
  RecoDummySource Q{dim=2;sizes={2,2};baseField=REAL;wordSize=8;dataRep=FLOAT;
                    data = {1,-3,4,5};frameDim=1};
  RecoMinMaxFilter M{verbose=true};
  RecoDummySink S;
  Q-&gt;M-&gt;S;
}
// result:
// minima[0]=-3,  maxima[0]=1
// minima[1]=4,  maxima[1]=5 </pre><p><br>
</p>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoMultFilter"></a>
RecoMultFilter</h1>
<p>Performs point-wise multiplication of multiple data streams. The mult
 filter combines multiple (identical) data streams to a single data 
stream which contains the point-wise product of the elements from the 
input data streams.</p>
<p><b> Parameters: </b><br>
 none.</p>
<p><b> Data Stream Requirements:</b><br>
 Real or complex data streams are supported, of type double precision 
floating point. All input streams must be of the same type (real / 
complex).</p>
<p><b> Data Structure Translation:</b><br>
 The output stream will inherit its structure from the first input 
stream, while it is asserted that all other input streams have the same 
structure.</p>
<p><b> Technical Details: </b><br>
 The filter does not work inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
    RecoMultFilter M;
    RecoDummySource Q1{wordSize=8;dataRep=FLOAT;};
    RecoDummySource Q2{wordSize=8;dataRep=FLOAT;};
    RecoDummySink    S;
    RecoPrintFilter  P1;
    RecoPrintFilter  P2:
    RecoPrintFilter  P3;
    Q1-&gt;P1-&gt;M; Q2-&gt;P2-&gt;M; M-&gt;P3-&gt;S;
}
// result: i * i = -1
// [0.00000e+00 + i1.00000e+00]
// [0.00000e+00 + i1.00000e+00]
// [-1.00000e+00 + i0.00000e+00] </pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoConjMultFilter"></a>
RecoConjMultFilter</h1>
<p>Performs point-wise multiplication of two complex valued data 
streams. The conjmult filter combines two (identical) data streams to a 
single data stream by multiplication of the first data stream (data) 
with the complex conjugate values of the second data stream (reference).
 Depending on the parameters, the filter can be utilized to remove the 
phase of the second data stream (reference) from the first data stream 
(data) without changing the amplitude of the first data stream.</p>
<pre class="fragment">&lt;b&gt; Parameters: &lt;/b&gt;&lt;br&gt;
&lt;table&gt;
&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Unit&lt;/th&gt;
    &lt;th&gt;Values&lt;/th&gt;&lt;th&gt;Required&lt;/th&gt;&lt;th&gt;Default&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;normalize&lt;/td&gt;
    &lt;td&gt;Amplitude of reference is set to 1. I.e. reference phase is removed from data without changing its amplitude.&lt;/td&gt;
    &lt;td&gt;bool&lt;/td&gt;
    &lt;td&gt;none&lt;/td&gt;
    &lt;td&gt;true/false&lt;/td&gt;
    &lt;td&gt;no&lt;/td&gt;
    &lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;b&gt; Data Stream Requirements:&lt;/b&gt;&lt;br&gt;
Exactly two complex data streams are supported, of type double precision 
floating point.

&lt;b&gt; Data Structure Translation:&lt;/b&gt;&lt;br&gt;
The output stream will inherit its structure from the first
input stream, while it is asserted that all other input streams have
the same structure.

&lt;b&gt; Technical Details: &lt;/b&gt;&lt;br&gt; 


&lt;b&gt; Example: &lt;/b&gt;&lt;br&gt;
</pre> <pre class="fragment">{
    RecoConjMultFilter M;
    RecoDummySource Q1{wordSize=8;dataRep=FLOAT;};
    RecoDummySource Q2{wordSize=8;dataRep=FLOAT;};
    RecoDummySink    S;
    RecoPrintFilter  P1;
    RecoPrintFilter  P2:
    RecoPrintFilter  P3;
    Q1-&gt;P1-&gt;M; Q2-&gt;P2-&gt;M; M-&gt;P3-&gt;S;
}
// result: i * i' = 1
// [0.00000e+00 + i1.00000e+00]
// [0.00000e+00 + i1.00000e+00]
// [1.00000e+00 + i0.00000e+00] </pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoParameterSink"></a>
RecoParameterSink</h1>
<p>Writes incoming data into an array parameter. The parameter sink 
stores the incoming data stream in a one-dimensional array parameter 
"data". Usually this parameter is aliased to a method parameter, which 
must be pre-defined and have suitable size. Complex data are stored with
 real and imaginary parts shuffled.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>data </td><td>(<b>output</b>) Parameter for storage of the data, will typically be aliased to a method parameter, e.g. data=&lt;RESULT&gt; </td><td>double[] </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 In setup mode this sink will only write to the part of the "data" parameter that is associated with a single repetition.</p>
<p><b> Data Stream Requirements:</b><br>
 The parameter sink supports only double precision floating point input data and parameters.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={3};wordSize=8;dataRep=FLOAT;baseField=REAL;
                     data={1,2,3};offset=1;};
   RecoPrintFilter P;
   RecoSquareRootFilter W;
   data = { 0,0,0 };     // allocate memory for data
   RecoParameterSink S{};
   Q-&gt;P-&gt;W-&gt;S;
}
{
    // use data as input
    RecoParameterSource Q{dim=1;sizes={3};wordSize=8;
                          dataRep=FLOAT;baseField=REAL;};
    RecoPrintFilter P;
    RecoDummySink S;
    Q-&gt;P-&gt;S;
}
// result:
// [2.00000e+00][3.00000e+00][4.00000e+00]
// [1.41421e+00][1.73205e+00][2.00000e+00]</pre><p><br>
  <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoParameterSource"></a>
RecoParameterSource</h1>
<p>Create data stream from a local or method parameter. The parameter 
source allows to effectively access large parameter arrays from within a
 reconstruction network.</p>
<p>The parameter "data" is a one-dimensional array of double precision 
floating point values which will be copied to the output data stream of 
the source. If this stream is to be interpreted as complex numbers, real
 and imaginary numbers must be shuffled. The structure of the data 
stream (dimension, sizes, ...) must be defined with the standard data 
descriptor parameters.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>data </td><td>Input data, one-dimensional array of values, complex 
data must be stored as shuffled real and imaginary data. Usually aliased
 to a method parameter. </td><td>double[] </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p>In addition, parameters listed under <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#DataDescriptor">DataDescriptor</a> can and should be specified in most cases.</p>
<p><b> Data Stream Requirements:</b><br>
 Only double precision floating point parameters are supported.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={4};wordSize=8;dataRep=FLOAT;baseField=REAL;
                     data={1,2,3,4};offset=1;};
   RecoPrintFilter P;
   RecoSquareRootFilter W;
   data = { 0,0,0,0 };     // allocate memory for data
   RecoParameterSink S{};
   Q-&gt;P-&gt;W-&gt;S;
}
{
    // use data as input
    RecoParameterSource Q{dim=1;sizes={2};wordSize=8;
                          dataRep=FLOAT;baseField=COMPLEX;};
    RecoPrintFilter P;
    RecoDummySink S;
    Q-&gt;P-&gt;S;
}
// result:
// [2.00000e+00][3.00000e+00][4.00000e+00][5.00000e+00]
// [1.41421e+00 + i1.73205e+00][2.00000e+00 + i2.23607e+00]</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoPCAFilter"></a>
RecoPCAFilter</h1>
<p>Performs data combination for PhasedContrastAngiography (PCA) 
acquired with a Hadamard flow encoding scheme. The PCA filter combines 
four inputs, hereafter called A, B, C, and D, calculating four outputs, 
called x_comp, y_comp, z_comp and static, in the following way: <br>
 </p><pre class="fragment">     x_comp = -A + B + C - D
     y_comp = -A + B - C + D
     z_comp = -A - B + C + D
     static = A + B + C + D </pre><p><b>Parameters: </b><br>
 none.</p>
<p><b> Connectors: </b><br>
 The connectors are not named, but are assigned to the input and output variables in the order of connection, i.e.: </p><ul>
<li>
IN[0] = A, IN[1] = B, IN[2] = C, IN[3] = D </li>
<li>
OUT[0] = x_comp, OUT[1] = y_comp, OUT[2] = z_comp and OUT[3] = static </li>
</ul>
<p><b> Data Stream Requirements:</b><br>
 The filter works on complex, double precision floating point data only. <br>
 All four input streams must have the same sizes.</p>
<p><b> Data Structure Translation: </b><br>
 The 4 output streams will have the same data description as the four input streams.<br>
</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q1{dim=1;sizes={2};baseField=COMPLEX;dataRep=FLOAT;
                      wordSize=8; data = { 1, 0, 0, 1} };
   RecoDummySource Q2{dim=1;sizes={2};baseField=COMPLEX;dataRep=FLOAT;
                      wordSize=8; data = { -1, 0, 0, 1} };
   RecoDummySource Q3{dim=1;sizes={2};baseField=COMPLEX;dataRep=FLOAT;
                      wordSize=8; data = { 0, 1, 0, 1} };
   RecoDummySource Q4{dim=1;sizes={2};baseField=COMPLEX;dataRep=FLOAT;
                      wordSize=8; data = { 0, -1, 0, 1} };
   RecoPrintFilter P1{format="%4.2f"};
   RecoPrintFilter P2{format="%4.2f"};
   RecoPrintFilter P3{format="%4.2f"};
   RecoPrintFilter P4{format="%4.2f"};
   RecoPCAFilter   PCA;
   RecoDummySink S1;
   RecoDummySink S2;
   RecoDummySink S3;
   RecoDummySink S4;
   Q1-&gt;PCA-&gt;P1-&gt;S1;
   Q2-&gt;PCA-&gt;P2-&gt;S2;
   Q3-&gt;PCA-&gt;P3-&gt;S3;
   Q4-&gt;PCA-&gt;P4-&gt;S4;
}
// result:
//[-2.00 + i2.00] [0.00 + i0.00]
//[-2.00 - i2.00] [0.00 + i0.00]
//[0.00 + i0.00] [0.00 + i0.00]
//[0.00 + i0.00] [0.00 + i4.00] </pre><p><br>
 <b> References: </b><br>
 <a href="http://www.e-mri.org/mr-angiography-flow/phase-contrast-mra.html">http://www.e-mri.org/mr-angiography-flow/phase-contrast-mra.html</a> <br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoPhasCorrFilter"></a>
RecoPhasCorrFilter</h1>
<p>Filter for linear phase correction. The filter performs a linear 
phase correction in a given (spatial) direction. It is parametrized by 
the constant phase correction value <img class="formulaInl" alt="$ \phi_0 $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_47.png"> and the linear phase increment factor <img class="formulaInl" alt="$ \phi_1 $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_48.png">,
 which describes the phase increment between subsequent points. The 
result is always complex. For the k-th point, the output point <img class="formulaInl" alt="$y_k$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_49.png"> is calculated from the input point <img class="formulaInl" alt="$x_k$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_50.png"> in the following way: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ y_k = \exp \left( \frac{2\pi\;i}{360^\circ} (\phi_1 k+ \phi_0)\right)\cdot x_k \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_51.png">
</p>
<p> In addition to these global correction values, also individual values can be specified for each frame.</p>
<p>In the frequency domain, the linear phase correction will correspond 
to a spatial shift. A phase difference of 180 degrees between two 
subsequent points corresponds to a shift by half of the frame size.<br>
</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>winDirection </td><td>spatial direction for window application </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;procDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>ph0 </td><td>global phase correction constant </td><td>double </td><td>degrees </td><td>0&nbsp;...&nbsp;360 </td><td>yes </td><td>0  </td></tr>
<tr>
<td>ph1 </td><td>global linear phase correction factor </td><td>double </td><td>degrees </td><td>0&nbsp;...&nbsp;360 </td><td>yes </td><td>0  </td></tr>
<tr>
<td>ph0Frame </td><td>additional phase correction constant, for individual frames </td><td>double[] </td><td>degrees </td><td>0&nbsp;...&nbsp;360 </td><td>no </td><td>0  </td></tr>
<tr>
<td>ph1Frame </td><td>additional linear phase correction factor, for individual frames </td><td>double[] </td><td>degrees </td><td>0&nbsp;...&nbsp;360 </td><td>no </td><td>0  </td></tr>
</tbody></table>
<p><br>
 <b> Data Stream Requirements:</b><br>
 The filter operates on floating point data. The procDim must match the winDirection.</p>
<p><b> Data Structure Translation: </b><br>
 The output will always be complex.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={4};baseField=REAL;dataRep=FLOAT;wordSize=4;
                     constant=true; offset=1;};
   RecoPhasCorrFilter C{ph0=180;ph1=90;};
   RecoPrintFilter P{format="%4.2f";};
   RecoDummySink S;
   Q-&gt;C-&gt;P-&gt;S;
}
// result:
// [-1.00 + i0.00] [-0.00 - i1.00] [1.00 - i0.00] [0.00 + i1.00] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoPhasedAccumFilter"></a>
RecoPhasedAccumFilter</h1>
<p>Accumulates subsequent scans with phase correction. The PhasesAccumFilter adds up ns subsequent scans <img class="formulaInl" alt="$ s_k $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_89.png"> while normalizing the phase of the first point to the phase of the first scan: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = \sum_{k=1}^{\rm ns} s_k \exp(2\pi i \phi_k) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_90.png">
</p>
<p> where <img class="formulaInl" alt="$\phi_1 = 0 $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_91.png"> and <img class="formulaInl" alt="$ \phi_k = {\rm arg}(s_1[0] \bar s_k[0]) $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_92.png">.
 The number of subsequent scans is read from the parameter "ns". The 
filter will operate only correctly, if the first point in each scan 
contains reliable phase information, i.e. it is not noise.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>ns </td><td>number of subsequent scans to be accumulated </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;sizes[1] </td><td>no </td><td>2  </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 The filter requires the license feature PVM_UTE, as it is specific for UTE reconstruction. It does not operate inplace.</p>
<p><b> Data Stream Requirements:</b><br>
 The dimension and procDim must be at least 2. The filter works on complex, double precision floating point data only.</p>
<p><b> Data Structure Translation: </b><br>
 The size in the second direction will be divided by ns: sizes[1] /= ns</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=2;sizes={2,2};procDim=2;dataRep=FLOAT;wordSize=8;
                     baseField=COMPLEX; data={0,1,1,0,1,0,1,0};};
   RecoPhasedAccumFilter PA{ns=2};
   RecoPrintFilter P{format="%4.2f"};
   RecoDummySink S;
   Q-&gt;PA-&gt;P-&gt;S;
}
// result:
// [0.00 + i2.00] [1.00 + i1.00] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoPhaseDiffFilter"></a>
RecoPhaseDiffFilter</h1>
<p>Calculates the phase difference of two input streams. This filter calculates the pointwise phase difference <img class="formulaInl" alt="$ \phi $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_52.png"> of two complex valued data streams as <img class="formulaInl" alt="$ \phi={\rm arg}(z_1 \bar z_2) $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_53.png">, corresponding to a subtraction of the phase of <img class="formulaInl" alt="$ z_2 $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_54.png"> from the phase of <img class="formulaInl" alt="$ z_1 $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_55.png">, and using the range <img class="formulaInl" alt="$(-\pi,\pi]$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_56.png"> for the result.</p>
<p><b> Connectors: </b><br>
 The filter has two named connectors: ".left" and ".right", which correspond to the left ( <img class="formulaInl" alt="$ z_1 $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_55.png">) and right hand side ( <img class="formulaInl" alt="$ z_2 $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_54.png">) of the complex multiplication, respectively.</p>
<p><b>Parameters: </b><br>
 none.</p>
<p><b> Data Stream Requirements:</b><br>
 The filter supports complex, double precision floating point input data
 only. Both input streams must have the same dimension and structure.</p>
<p><b> Data Structure Translation: </b><br>
 The resulting stream is real, double precision floating point data.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q1{dim=1;sizes={2};dataRep=FLOAT;wordSize=8;baseField=COMPLEX;
                       data = {0,1,1,1};};
   RecoDummySource Q2{dim=1;sizes={2};dataRep=FLOAT;wordSize=8;baseField=COMPLEX;
                       data = {-1,0,-1,-1};};
   RecoPhaseDiffFilter D;
   RecoPrintFilter P;
   RecoDummySink S;
   Q1-&gt;D.left;
   Q2-&gt;D.right;
   D-&gt;P-&gt;S;
}
// result:
// [-1.57080e+00][3.14159e+00]</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1 class=""><a class="anchor" id="RecoPhaseFilter"></a>
RecoPhaseFilter</h1>
<p>Determines the phase of the input data. This filter calculates the phase <img class="formulaInl" alt="$ \phi $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_52.png"> of each input value, <img class="formulaInl" alt="$ z $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_57.png">, based on its real and imaginary parts: <img class="formulaInl" alt="$ \phi = \arctan\left({\rm imag}(z)/{\rm real}(z)\right) $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_58.png">. The phase is assigned to the range (-pi,+pi], which is the default, or to the range (0,2pi].</p>
<p>To avoid phase noise, a noise level can be defined, such that input 
values will be assigned zero phase, if the absolute values of real and 
imaginary part are lower than that level. Noise levels can be defined in
 an absolute or relative manner. For a relative value, the noise level 
will be relative to the maximum input value per frame.</p>
<div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/PhaseFilter.png" alt="PhaseFilter.png">
<div class="caption">
Phase calculation</div></div>
<p> <b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>noiseLevel </td><td>Absolute noise level, below which the phase will
 be set to zero. If a relative noise level is also defined, that is used
 instead.  </td><td>double </td><td>none </td><td>&gt;= 0.0 </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>relativeNoise </td><td>The relative noise level, below which the 
phase will be set to zero. Refers to the maximum real or imaginary value
 within each frame. </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;1.0 </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>stdRange </td><td>Switches between two conventions for the range of the output phase values. </td><td>bool </td><td>none </td><td>true:&nbsp;(-pi,+pi]<br>
 false:&nbsp;(0,2pi] </td><td>no </td><td>true  </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 The filter does not operate in place. Phase calculation is based on the
 atan2 standard math function. Relative noise level specification will 
influence performance, as the maximum value has to be determined in 
advance.</p>
<p><b> Data Stream Requirements:</b><br>
 The filter operates on single/double precision floating point data 
only. If a relative noise level is defined, the processing dimension 
must be greater or equal to the frame dimension.</p>
<p><b> Data Structure Translation: </b><br>
 Input data can be real or complex. In case of real input, the phase 
will be zero at every point. The output data is always real.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
    RecoDummySource Q{dim=1;sizes={4};dataRep=FLOAT;};
    RecoPhaseFilter PH{relativeNoise=0.25};
    RecoPrintFilter P1{format="%2.0f"};
    RecoPrintFilter P2{format="%1.6f"};
    RecoDummySink S;
    Q-&gt;P1-&gt;PH-&gt;P2-&gt;S;
}
-------------------------------------------
[ 0 + i 1] [ 2 + i 3] [ 4 + i 5] [ 6 + i 7] 
-------------------------------------------
-------------------------------------------
[0.000000] [0.982794] [0.896055] [0.862170] 
-------------------------------------------</pre><p><br>
 <b> References: </b><br>
 man 3 atan2 <br>
</p>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoPhaseWeightingFilter"></a>
RecoPhaseWeightingFilter</h1>
<p>Performs phase weighting for susceptibility weighted imaging. This 
filter has two inputs (original data and pre-filtered data), and one 
output, which replicates the original data, weighted by the phase 
difference of the two inputs.</p>
<p>There are four different types of phase weighting, which can be selected via the parameter "mask": </p><ol>
<li>
weight only regions with a positive phase difference </li>
<li>
weight only regions with a negative phase difference </li>
<li>
weight everywhere, using the magnitude of the phase difference as the weighting factor </li>
<li>
display pure phase difference image </li>
</ol>
<p>In order to control the phase contrast in the output image, the phase
 difference can be exponentiated before being applied as weighting 
factor, by adjusting the parameter "weighting".</p>
<p>The pre-filtered data could, e.g., be generated by applying a 
Gaussian filter to the original data. This would result in strong 
weighting in regions where the phase in the original data changes 
rapidly on small scales.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>mask </td><td>Select type of phase mask </td><td>int </td><td>none </td><td>1:positive&nbsp;mask, 2:negative&nbsp;mask, 3:magnitude&nbsp;mask, 4:phase&nbsp;image </td><td>no </td><td>1  </td></tr>
<tr>
<td>weighting </td><td>Power of phase weighting </td><td>double </td><td>none </td><td>- </td><td>no </td><td>4.0  </td></tr>
</tbody></table>
<p><b> Connectors: </b><br>
 Two input data streams are expected:</p><ul>
<li>.data: original complex data</li>
<li>.mask: pre-filtered complex data</li>
</ul>
<p><b> Technical Details: </b><br>
 The filter requires the license feature PVM_SWI, as it is specific for 
susceptibility weighted imaging. It does not operate inplace.</p>
<p><b> Data Stream Requirements:</b><br>
 The filter works on complex, double precision floating point data only. Both input streams must have the same sizes.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q1{dim=1;sizes={1};dataRep=FLOAT;baseField=COMPLEX;wordSize=8;
                      data={0,1};};
   RecoDummySource Q2{dim=1;sizes={1};dataRep=FLOAT;baseField=COMPLEX;wordSize=8;
                      data={1,0};};
   RecoPhaseWeightingFilter PW{mask=1; weighting = 4};
   RecoPrintFilter P;
   RecoDummySink S;
   Q1-&gt;PW.data;
   Q2-&gt;PW.mask;
   PW-&gt;P-&gt;S;
}
// result:
// [0.00000e+00 + i6.25000e-02] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoPIGrappaCalibFilter"></a>
RecoPIGrappaCalibFilter</h1>
<p>Calculates GRAPPA kernel. Uses reference data from multiple 
(numRxChan) receive channels to calculate a set of coefficients (GRAPPA 
kernel) to be used in GRAPPA image reconstruction.</p>
<p>The matrix inversion involved in this calculation is implemented as a singular value decomposition.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>accelFactor </td><td>GRAPPA acceleration factor </td><td>int </td><td>- </td><td>2&nbsp;...&nbsp;numRxChan </td><td>yes </td><td>-  </td></tr>
<tr>
<td>numCalibBlocksRead </td><td>Number of calibration blocks in read direction </td><td>int </td><td>- </td><td>&gt;=1,&nbsp;odd </td><td>yes </td><td>-  </td></tr>
<tr>
<td>numCalibBlocksPhase </td><td>Number of calibration blocks in phase direction </td><td>int </td><td>- </td><td>&gt;=2,&nbsp;even </td><td>yes </td><td>-  </td></tr>
<tr>
<td>truncThresh </td><td>Threshold for inverse condition number in 
matrix inversion. Singular values smaller that truncThresh times the 
largest singular value are treated as zero. </td><td>double </td><td>- </td><td>&gt;0.0<br>
-1.0: use machine precision </td><td>no </td><td>-1.0  </td></tr>
</tbody></table>
<p><b> Connectors: </b><br>
 This filter accepts input carriers from up to 32 receive channels, named .RL000,&nbsp;.RL001&nbsp;...&nbsp;RL032.<br>
 The single output carrier contains the GRAPPA coefficients.</p>
<p><b> Technical Details: </b><br>
 The filter requires the license feature PV_PI_GRAPPA, as it is specific for GRAPPA parallel imaging.</p>
<p><b> Data Stream Requirements:</b><br>
 This filter supports only complex, double precision floating point 
data. The data dimension must be 2 or larger, the procDim must be equal 
to 2. All input carriers must have the same structure. <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoPIGrappaRecoFilter"></a>
RecoPIGrappaRecoFilter</h1>
<p>Performs GRAPPA reconstruction. This filter performs a GRAPPA 
reconstruction from undersampled k-spaces in multiple (numRxChan) 
receive channels, using a set of calibration coefficients (GRAPPA 
kernel). The result are numRxChan complete k-spaces, that can be Fourier
 transformed without generating undersampling artifacts. The total 
number of phase encoding steps in the fully sampled k-space is denoted 
by "numPhLines". The position of reference lines can be specified either
 via the parameters centerLine and numRefLines, if the reference lines 
are located symmetrically around the central k-space line. For 
asymmetric reference lines, the parameters centerLine, firstRefLine, and
 lastRefLine must be used.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>accelFactor </td><td>GRAPPA acceleration factor </td><td>int </td><td>- </td><td>2&nbsp;...&nbsp;numRxChan </td><td>yes </td><td>-  </td></tr>
<tr>
<td>numRecoBlocksRead </td><td>Number of reconstruction blocks in read direction </td><td>int </td><td>- </td><td>&gt;=1,&nbsp;odd </td><td>yes </td><td>-  </td></tr>
<tr>
<td>numRecoBlocksPhase </td><td>Number of reconstruction blocks in phase direction </td><td>int </td><td>- </td><td>&gt;=2,&nbsp;even </td><td>yes </td><td>-  </td></tr>
<tr>
<td>centerLine </td><td>Position of central k-space line </td><td>int </td><td>- </td><td>0&nbsp;...&nbsp;numPhLines </td><td>yes </td><td>-  </td></tr>
<tr>
<td>numRefLines </td><td>Number of reference lines </td><td>int </td><td>- </td><td>0&nbsp;...&nbsp;numPhLines </td><td>if firstRefLine and lastRefLine parameters are not specified </td><td>-  </td></tr>
<tr>
<td>firstRefLine </td><td>Position of first reference line </td><td>int </td><td>- </td><td>0&nbsp;...&nbsp;numPhLines </td><td>if numRefLines is not specified </td><td>-  </td></tr>
<tr>
<td>lastRefLine </td><td>Position of last reference line </td><td>int </td><td>- </td><td>firstRefLine&nbsp;...&nbsp;numPhLines </td><td>if numRefLines is not specified </td><td>-  </td></tr>
<tr>
<td>coeffForFirstRepOnly </td><td>Coefficients are only available for first repetition </td><td>bool </td><td>- </td><td>true/false </td><td>no </td><td>false  </td></tr>
</tbody></table>
<p><b> Connectors: </b><br>
 The input consists of numRxChan+1 named connectors: </p><ul>
<li>
.COEFF: Grappa coefficients, as determined by the <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoPIGrappaCalibFilter">RecoPIGrappaCalibFilter</a>. </li>
<li>
.KDATA000, .KDATA001, ... : Two-dimensional undersampled k-space inputs of numRxChan (up to 32) receive channels. </li>
</ul>
<p>The output consists of numRxChan named connectors ".KDATA000", 
".KDATA001", ..., delivering two-dimensional, fully sampled k-spaces for
 each receive channel.</p>
<p><b> Technical Details: </b><br>
 The filter requires the license feature PV_PI_GRAPPA, as it is specific for GRAPPA parallel imaging.</p>
<p><b> Data Stream Requirements:</b><br>
 This filter supports only complex, double precision floating point 
data. The dimension of all input data carriers must be 2 or larger and 
the procDim must be equal to 2. All KDATA input carriers must have the 
same data structure. <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoPIRefExtractFilter"></a>
RecoPIRefExtractFilter</h1>
<p>Extracts reference data from parallel imaging data. From a 
two-dimensional input data stream, a rectangular range of points is 
copied to a separate output, to be used as reference data in a following
 GRAPPA calibration filter. The range of the reference data in read and 
phase directions can be specified either via the parameters 
extractStartRead, extractStopRead, extractStartPhase, and 
extractStopPhase, determining the boundary in k-space, or via the 
parameters readCenter, phaseCenter, numRefRead, and numRefPhase, 
determining the center and width in k-space.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>extractStartRead </td><td>first point of reference data in read direction </td><td>int </td><td>- </td><td>&gt;=0 </td><td>if center and number parameters are not specified </td><td>-  </td></tr>
<tr>
<td>extractStopRead </td><td>last point of reference data in read direction </td><td>int </td><td>- </td><td>&gt;=extractStartRead </td><td>if center and number parameters are not specified </td><td>-  </td></tr>
<tr>
<td>extractStartPhase </td><td>first point of reference data in phase direction </td><td>int </td><td>- </td><td>&gt;=0 </td><td>if center and number parameters are not specified </td><td>- </td></tr>
<tr>
<td>extractStopPhase </td><td>last point of reference data in phase direction </td><td>int </td><td>- </td><td>&gt;=extractStartPhase </td><td>if center and number parameters are not specified </td><td>-  </td></tr>
<tr>
<td>readCenter </td><td>center point of reference data in read direction </td><td>int </td><td>- </td><td>&gt;=0 </td><td>if start and stop parameters are not specified </td><td>-  </td></tr>
<tr>
<td>phaseCenter </td><td>center point of reference data in phase direction </td><td>int </td><td>- </td><td>&gt;=0 </td><td>if start and stop parameters are not specified </td><td>-  </td></tr>
<tr>
<td>numRefRead </td><td>number of points of reference data in read direction </td><td>int </td><td>- </td><td>&gt;=0 </td><td>if start and stop parameters are not specified </td><td>-  </td></tr>
<tr>
<td>numRefPhase </td><td>number of points of reference data in phase direction </td><td>int </td><td>- </td><td>&gt;=0 </td><td>if start and stop parameters are not specified </td><td>-  </td></tr>
<tr>
<td>refFromFirstRepOnly </td><td>extract reference data only from first repetition </td><td>bool </td><td>- </td><td>true/false </td><td>no </td><td>false  </td></tr>
</tbody></table>
<p><b> Connectors: </b><br>
 This filter has one input connector and two named output connectors: </p><ul>
<li>
.REFDATA: Extracted reference data </li>
<li>
.KDATA: complete, unchanged k-space data from the input </li>
</ul>
<p><b> Technical Details: </b><br>
 The filter requires the license feature PV_PI_GRAPPA, as it is specific for GRAPPA parallel imaging.</p>
<p><b> Data Stream Requirements:</b><br>
 The data dimension must be 2 or larger, the procDim must be equal to 2. <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoPrintFilter"></a>
RecoPrintFilter</h1>
<p>Prints the input data stream to stdout or to a file. The print filter
 writes the content of the connected stream in a user definable format 
to a given file. If no filename is specified, it writes to stdout. A 
specified file must be writeable, otherwise an IOError exception is 
thrown.</p>
<p>A format can be specified, which will be used to write each single 
word. For complex points, the output will be of the form 
&lt;real&gt;&nbsp;+/-&nbsp;i&lt;imag&gt;, where the sign depends on the 
sign of the imaginary part. Further formatting options are left and 
right delimiter strings, which are used to separate distinct points, a 
separator line which is used to distinguish subsequent calls of the 
filter function and finally a row size, which determines, after how many
 points a line break will be inserted.</p>
<p>Similar results can be achieved with a file sink, where an ascii mode is available, however, with no formating options.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>rowsize </td><td>Number of points to be printed per line. For rowsize=0 all points will be printed on one line. </td><td>int </td><td>points </td><td>&gt;= 1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>filename </td><td>Name of file where to write the data. If empty, 
stdout is used. An IO exception will be thrown, if the file cannot be 
opened for writing. </td><td>string </td><td>none </td><td>- </td><td>no </td><td>stdout  </td></tr>
<tr>
<td>format </td><td>C style like format specifier, which replaces the 
default setting for printing numbers, which is data type specific. 
Default are %d for int, %u for unsigned and %.5e for floating point 
numbers. </td><td>string </td><td>none </td><td>- </td><td>no </td><td>"%d","%u","%.5e" depending on data format  </td></tr>
<tr>
<td>eps </td><td>A small real number, larger than zero. All floating 
point numbers whose absolute values are less than eps are printed as if 
they were exactly equal to zero. </td><td>double </td><td>none </td><td>&gt;0.0 </td><td>no </td><td>-  </td></tr>
<tr>
<td>leftDelimiter </td><td>String to be used to signify the start of a point.  </td><td>string </td><td>none </td><td></td><td>no </td><td>"["  </td></tr>
<tr>
<td>rightDelimiter </td><td>String to be used to signify the end of a point.  </td><td>string </td><td>none </td><td></td><td>no </td><td>"]"  </td></tr>
<tr>
<td>separator </td><td>String which will be used to separate different calls of the filter.  </td><td>string </td><td>none </td><td></td><td>no </td><td>"-----------------------------------\n"  </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 The filter runs in exclusive mode, and can operate inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
     RecoDummySource Q{dim=2; sizes={4,2}; dataRep=FLOAT};
     RecoDummySink S;
     RecoPrintFilter P{rowsize=2;leftDelimiter="&lt;";rightDelimiter="&gt;";
                       separator=""; format="%.2e"};
     Q-&gt;P-&gt;S;
}
// result:
//  &lt;0.00e+00 + 1.00e+00&gt;&lt;2.00e+00 + 3.00e+00&gt;
//  &lt;4.00e+00 + 5.00e+00&gt;&lt;6.00e+00 + 7.00e+00&gt;
//
//  &lt;8.00e+00 + 9.00e+00&gt;&lt;1.00e+01 + 1.10e+01&gt;
//  &lt;1.20e+01 + 1.30e+01&gt;&lt;1.40e+01 + 1.50e+01&gt;
// </pre><p> <br>
 <b> References: </b><br>
 man 3 printf <br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoReformatFilter"></a>
RecoReformatFilter</h1>
<p>Reformats the data description. The reformat filter reshapes the data
 array structure without modifying the data and data type. The filter 
has three operation modes. The first option is to give the new array 
size using the parameter newSizes. The dimension of the new array 
(newDim) is implicitly given by the length of newSizes. The second 
option is to drop a specific direction of the array. If the size of that
 direction is greater than one, the size is transferred to the next 
higher array dimension. If both newSizes and dropDirection are defined, 
only newSizes will be used. The third option is to only specify a new 
value for the processing dimension. In this case, the block 
dimensionality and sizes are not changed.</p>
<p>In newSizes mode, the filter can also increase or decrease the 
processing dimension to procDim = 1 ... newDim. In dropDirection mode, 
the filter requires that the input processing dimension is at least the 
dropDirection plus one, if the size of the direction to be dropped is 
greater than one.</p>
<p>With the parameters procDim and frameDim the processing dimension and
 frame dimension of the output data can be specified. If these 
parameters are not given, and if newDim is equal or larger than the 
dimension of the input data description, frameDim or procDim remain 
unchanged. If newDim becomes smaller, frameDim or procDim are reduced, 
to not exceed newDim.</p>
<p>The reformat filter can also be used to provide workarounds, e.g., if
 ACQ parameter descriptions for methods like UTE 3D need to be 
reinterpreted for reconstruction.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>dropDirection </td><td>Direction which will be dropped in data description. If set to -1, no dimension will be dropped. </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;dim-1 </td><td>no, if newSizes specified or if only procDim is changed. </td><td>-1  </td></tr>
<tr>
<td>newSizes </td><td>New sizes of the array </td><td>int[] </td><td>none </td><td>product(newSizes)=product(sizes) </td><td>no, if dropDirection specified or if only procDim is changed. </td><td>-  </td></tr>
<tr>
<td>procDim </td><td>new processing dimension </td><td>int </td><td>none </td><td>- </td><td>if newDim &gt; dim </td><td>-  </td></tr>
<tr>
<td>frameDim </td><td>new frame dimension </td><td>int </td><td>none </td><td>- </td><td>no </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Structure Translation: </b><br>
 The output data descriptor will be set to the new dimensions. If frame 
and processing dimensions are larger, they are modified appropriately.</p>
<p><b> Technical Details: </b><br>
 The filter does not modify data. It can only work in-place, if the 
number of points of an output procDim-Block is equal to the number of 
points of an input procDim-Block. <b> Examples: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=3;sizes={2,1,3};baseField=REAL};
   RecoReformatFilter R{dropDirection=1;};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;R-&gt;P-&gt;S;
}
// result:
// [0] [1]
// [2] [3]
// [4] [5] 

{
   RecoDummySource Q{dim=2;sizes={2,4};baseField=REAL;procDim=1};
   RecoPrintFilter Pin;
   RecoReformatFilter R{newSizes={2,2,2};procDim=2};
   RecoPrintFilter Pout;
   RecoDummySink S{verbose=true};
   Q-&gt;Pin-&gt;R-&gt;Pout-&gt;S;
}
// result:
// [0] [1] 
// [2] [3] 
// [0] [1] [2] [3] 
// [4] [5] 
// [6] [7] 
// [4] [5] [6] [7]
</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoRegridApodCorrFilter"></a>
RecoRegridApodCorrFilter</h1>
<p>Performs apodization correction after regridding. The interpolation performed during regridding with the <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRegridNFilter">RecoRegridNFilter</a>
 is implemented as a convolution with a Kaiser-Bessel kernel. Hence, the
 Fourier transformed data is weighted with the Fourier transformation of
 that kernel. This results in a shading of the image (also called 
apodization) and can be undone with the present filter (after the 
Fourier transformation of the data, see also the figure at <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRegridNFilter">RecoRegridNFilter</a>).</p>
<p>For each dimension along which regridding has taken place, the 
apodization correction must be performed separately, with the parameter 
"winDirection" set accordingly.</p>
<p><b> Parameters: </b><br>
 Note: The input parameters must match those used during the regridding. </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit</th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>kernelWidth </td><td>width of interpolation kernel </td><td>double </td><td>intervals of oversampled grid </td><td>&gt; 0.0 </td><td>no </td><td>4.0  </td></tr>
<tr>
<td>kernelShapePar </td><td>shape parameter of interpolation kernel </td><td>double </td><td>- </td><td>&gt; 0.0 </td><td>no </td><td>7.0  </td></tr>
<tr>
<td>size </td><td>size of oversampled data; only required if the input data has already been cut after regridding and Fourier transformation </td><td>unsigned int </td><td>points </td><td>&gt;= 0<br>
(0: set to size of input data) </td><td>no </td><td>0  </td></tr>
<tr>
<td>winDirection </td><td>Direction along which the filter will be applied. </td><td>unsigned int </td><td>- </td><td>&gt;= 0 </td><td>no </td><td>0  </td></tr>
</tbody></table>
<p>Find more information in <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRegridNFilter">RecoRegridNFilter</a>. <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoRegridDensCorrFilter"></a>
RecoRegridDensCorrFilter</h1>
<p>Performs density correction of spiral or radial data. <b> Connectors:</b><br>
 One input data stream is expected, the k-space trajectory.</p><ul>
<li>It provides the k-space position for each sample value in the order 
of the acquisition. Generally, in each interleaf, the magnitudes of the 
k-values are expected to be strictly monotonic. Only at the beginning or
 at the end, points with identical k-values are neglected.</li>
<li>The first dimension holds the 2 or 3 k-values in k-units.</li>
<li>The second dimension counts the samples per interleaf.</li>
<li>The third dimension counts interleaves. This dimension must exist, 
even if there is only a single interleaf, in this case its size must be 
1.</li>
<li>All further dimensions hold additional slices (volumes) for different locations or time points.</li>
</ul>
<p>There is one output connector, containing a density correction value 
for each sample of the k-space trajectory, and is usually connected to 
the .dens input of the <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRegridNFilter">RecoRegridNFilter</a>.</p>
<p>See <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRegridNFilter">RecoRegridNFilter</a> for a description of k-units.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit</th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>type </td><td>type of density correction </td><td>string </td><td>- </td><td>"jacobian" = approach according to Hoge (spiral and radial)<br>
"rho" = rho filter (radial) </td><td>no </td><td>"jacobian"  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The input data must be real, double precision floating point data of dimension &gt;= 3.</p>
<p><b> Data Structure Translation:</b><br>
 The output data will be real, double precision, floating point data, 
with one density correction value for each sample. Thus, first dimension
 of the input data is removed.</p>
<p><b> Technical Details:</b><br>
 The filter does not work inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">/// 2D radial density correction (rho)
/// 1 projection, - to +
{
  // trajectory data
  RecoParameterSource T 
  {
    dim = 3;
    procDim = 3;
    sizes = {2, 8, 1};
    dataRep = FLOAT;
    wordSize = 8;
    baseField = REAL;
    data = {-4,0, -3,0, -2,0, -1,0, 0,0, 1,0, 2,0, 3,0};
  };
 
  // regrid
  RecoRegridDensCorrFilter DC {type = "rho"};
 
  // output
  RecoPrintFilter P;
  RecoDummySink S;
   
  T-&gt;DC;
  DC-&gt;P;
  P-&gt;S;
}
// result with sizes = {8, 1}
// [3.20000e+01] [2.40000e+01] [1.60000e+01] [8.00000e+00] [1.00000e+00] [8.00000e+00] [1.60000e+01] [2.40000e+01]</pre><p><b> References: </b><br>
 R.D. Hoge et al., Density compensation functions for spiral MRI, MRM 38:117-128 (1997)</p>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoRegridFilter"></a>
RecoRegridFilter</h1>
<p>Performs 1D regridding. The filter implements line regridding as 
typically needed in imaging methods which sample during gradient ramps. 
The filter is based on convolution reconstruction techniques. See the 
reference below for more details on regridding.</p>
<p>A ramp can be specified via the parameter "rampForm", selecting its 
form or selecting an input file, containing possibly multiple 
(nrTrajectories) trajectories.</p>
<p>For the built-in ramps, the fraction of the scan which is ramped is 
described by the parameter rampLength. If rampForm=5, one measured 
trajectory will be used (stored in parameters kspaceData and b0Data, 
both being arrays with length ksize). The coordinate transformation 
function calculated by integrating the assumed gradient function can be 
shifted by a constant number of points (parameter shift). This can be 
used, e.g, in UTE to compensate for misadjusted gradient ramps.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>rampForm </td><td>Select description of ramp </td><td>int </td><td>none </td><td>STARTRAMP=1,FILERAMP=2,TRAPEZOIDAL=3,SINUSOIDAL=4,KTRAJECT=5 </td><td>no </td><td>TRAPEZOIDAL=3  </td></tr>
<tr>
<td>rampLength </td><td>Fraction of the whole scan which consists of a ramp. </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;1.0 </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>nrTrajectories </td><td>Number of trajectories provided in external file referred to by fileName. </td><td>int </td><td>none </td><td>- </td><td>no </td><td>1  </td></tr>
<tr>
<td>fileName </td><td>Reference to trajectory file if rampForm=2 (FILERAMP). </td><td>string </td><td>none </td><td>- </td><td>if rampForm=2 </td><td>""  </td></tr>
<tr>
<td>shift </td><td>Specify (possibly sub-pixel) shift of derived coordinate map. </td><td>double </td><td>points </td><td>- </td><td>yes </td><td>0.0  </td></tr>
<tr>
<td>ksize </td><td>length of measured k-space trajectory </td><td>int  </td><td>none  </td><td>&gt;=0  </td><td>if rampForm=5 </td><td>0   </td></tr>
<tr>
<td>ktraject </td><td>Measured k-space trajectory (in k-space units) </td><td>double[ksize] </td><td>none  </td><td>double  </td><td>if rampForm=5 </td><td>NULL   </td></tr>
<tr>
<td>b0traject </td><td>Measured phase evolution of trajectory  </td><td>double[ksize] </td><td>none  </td><td>double  </td><td>if rampForm=5  </td><td>NULL   </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 This filter supports floating point data only.</p>
<p><b> Data Structure Translation: </b><br>
 Size[0] is changed according to the integral of the ramp - usually the size is reduced.</p>
<p><b> Example: </b><br>
 The following figure shows the (inverse) gradient integral resulting 
from applying trapezoidal regridding with 40% rampLength to the identity
 function. It was created by the example code below, but with data 
sizes[0] equal to 1000.</p>
<div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/RegridTrapez.png" alt="RegridTrapez.png">
<div class="caption">
Regridding of trapezoidal ramps</div></div>
 <pre class="fragment">// example for trapezoidal ramp
{
   RecoDummySource Q{dim=1;sizes={32};baseField=REAL;dataRep=FLOAT;wordSize=8;
                     constant=false;offset=0;};
   RecoRegridFilter R{rampForm=3;rampLength=0.4;};
   RecoPrintFilter P{rowsize=4;format="%5.2f"};
   RecoDummySink S{verbose=true};
   Q-&gt;R-&gt;P-&gt;S;
}
// result: notice how the output size is recalculated!
// Sink&lt;S&gt; ...
// size[0]=20
// [ 0.88] [ 4.44] [ 6.42] [ 8.00]
// [ 9.28] [10.49] [11.27] [12.53]
// [13.46] [14.49] [15.50] [16.45]
// [17.55] [18.11] [19.58] [20.59]
// [22.32] [22.63] [27.92] [14.51]</pre> <pre class="fragment">&lt;b&gt; Reference: &lt;/b&gt;&lt;br&gt;
</pre><p> John I. Jackson et al., Selection of a Convolution Function 
for Fourier Inversion Using Gridding, IEEE Transactions of Medical 
Imaging, Vol. 10, No3 September 1991,pp 473-478<br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoRegridNFilter"></a>
RecoRegridNFilter</h1>
<p>Performs regridding of arbitrarily sampled 2D and 3D k-space data 
onto a Cartesian grid. This filter calculates a Cartesian k-space from 
data acquired using a non-Cartesian k-space trajectory, and from the 
k-space coordinates visited by that trajectory. It uses uses a standard 
data-driven algorithm, i.e. each input point is added to the Cartesian 
grid positions with an appropriate weight, which depends on the distance
 of the k-space coordinate to the Cartesian coordinate. For calculating 
these weights, a Kaiser-Bessel kernel is used.</p>
<p><b>Trajectory convention:</b><br>
 The trajectory must be given in k-units. These are normalized k-space units.</p>
<p>For an equidistant Cartesian grid the common relationships in and between real ( <img class="formulaInl" alt="$x$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_4.png">) and reciprocal ( <img class="formulaInl" alt="$k$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_59.png">) space are: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\Delta x = N \cdot dx \hspace{0.5cm},\hspace{0.5cm} \Delta k = N \cdot dk\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_60.png">
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[dx = \frac{1}{\Delta k} \hspace{0.5cm},\hspace{0.5cm} dk = \frac{1}{\Delta x}\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_61.png">
</p>
<p> with the following definitions:</p><ul>
<li><img class="formulaInl" alt="$N$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_0.png"> is the number of points as well as intervals in both domains.</li>
<li>The ranges covered are <img class="formulaInl" alt="$\Delta x$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_62.png">, which is the field-of-view, and <img class="formulaInl" alt="$\Delta k$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_63.png">.</li>
<li>The interval sizes are <img class="formulaInl" alt="$dx$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_64.png">, which is the spatial resolution, and <img class="formulaInl" alt="$dk$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_65.png">.</li>
</ul>
<p>Normalization is performed according to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[x' = \frac{x}{dx} \hspace{0.5cm},\hspace{0.5cm} k' = k \cdot dx\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_66.png">
</p>
<p> leading to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[dx' = 1 \hspace{0.5cm},\hspace{0.5cm} dk' = \frac{1}{N}\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_67.png">
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[\Delta x' = N \hspace{0.5cm},\hspace{0.5cm} \Delta k' = 1\]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_68.png">
</p>
<p> Consequently, centered, normalized k-values are in the range [-0.5, 0.5], and only <img class="formulaInl" alt="$N$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_0.png"> is required in addition to normalized k-values to completely describe the trajectory.</p>
<p><b> Connectors: </b><br>
 Two or three input data streams are expected:</p><ul>
<li>.data is arbitrarily sampled k-space data from, e.g., spiral or radial sampling.<ul>
<li>Its first dimension holds the data per interleaf.</li>
<li>The second dimension counts interleaves. This dimension must exist, 
even if there is only a single interleaf, in this case its size must be 
1.</li>
<li>All further dimensions hold additional slices for different locations or time points.</li>
</ul>
</li>
<li>.traj provides the k-space position for each sampled value of .data.<ul>
<li>The first dimension holds the k-values (in normalized units) of the 
trajectory, in shuffled order: kx1, ky1, kx2, ky2, ... or kx1, ky1, kz1,
 kx2, ky2, kz3, ... .</li>
<li>Further dimensions have the equivalent meanings as for .data, but with a shift of 1.</li>
</ul>
</li>
<li>.dens contains the density correction that has already been applied to .data.<ul>
<li>It is only required, if postCorrection=2.</li>
<li>It has the same data structure as .data.</li>
</ul>
</li>
</ul>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit</th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>outputX </td><td>size of Cartesian output grid in 1st direction (including oversampling) </td><td>unsigned int </td><td>points </td><td>&gt; 1 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>outputY </td><td>size of Cartesian output grid in 2nd direction (including oversampling) </td><td>unsigned int </td><td>points </td><td>&gt; 1 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>outputZ </td><td>size of Cartesian output grid in 3rd direction (including oversampling) </td><td>unsigned int </td><td>points </td><td>&gt;= 1 </td><td>no </td><td>1  </td></tr>
<tr>
<td>kernelWidth </td><td>width of interpolation kernel </td><td>double </td><td>intervals of oversampled grid </td><td>&gt; 0.0 </td><td>no </td><td>4.0  </td></tr>
<tr>
<td>kernelShapePar </td><td>shape parameter of interpolation kernel </td><td>double </td><td>- </td><td>&gt; 0.0 </td><td>no </td><td>7.0  </td></tr>
<tr>
<td>kernelSampDens </td><td>sampling density of pre-calculated interpolation kernel </td><td>unsigned int </td><td>samples per interval of oversampled grid </td><td>&gt; 0 </td><td>no </td><td>1000  </td></tr>
<tr>
<td>postCorrection </td><td>apply density correction after gridding </td><td>unsigned int </td><td>- </td><td>0: none<br>
 1: only post<br>
 2: post after pre (requires pre-correction data as additional input)  </td><td>no </td><td>false  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The following conditions of the input data are verified:</p><ul>
<li>.data provides shuffled complex, double precision floating point data of dimension &gt;= 1.</li>
<li>.traj provides real, double precision floating point data of of dimension &gt;= 2.</li>
<li>.dens provides real, double precision floating point data of of dimension &gt;= 1.</li>
<li>The respective sizes of all dimensions must agree.</li>
</ul>
<p><b> Data Structure Translation: </b><br>
</p><ul>
<li>The output data will be shuffled complex, double precision floating point data in k-space of dimension &gt;= 2.</li>
<li>The size of a slice is determined by outputX, outputY, and outputZ.</li>
<li>The number of slices will be identical to the input data.</li>
</ul>
<p>Note: For the 3D case "slice" means a 3D volume.</p>
<p><b> Technical Details: </b><br>
 The filter does not work inplace.</p>
<p><b> Application: </b><br>
 For a full reconstruction with regridding, the order of filters may look as follows: </p><div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/RegridFilterOrder.png" alt="RegridFilterOrder.png">
</div>
<p>Parameters related to regridding form the group <em>RecoRegridNGroup</em>.</p>
<p><b> Example: </b><br>
 In this example, both trajectory and measured samples are read from files. </p><pre class="fragment">/// 2D spiral with density correction
{
  // read trajectory from file
  RecoFileSource QT
  {
    filename = "traj.dat";
    dim = 3;
    procDim = 3;
    sizes = {2, 1070, 1};
    dataRep = FLOAT;
    wordSize = 8;
    baseField = REAL;
  };
  
  // read data from file
  RecoFileSource QD
  {
    filename = "samples.dat";
    dim = 2;
    procDim = 2;
    sizes = {1070, 1};
    dataRep = FLOAT;
    wordSize = 8;
    baseField = COMPLEX;
    shuffle = true;
  };
    
  // duplicate trajectory
  RecoTeeFilter T;

  // density correction
  RecoRegridDensCorrFilter DC;
  RecoMultFilter MU;
  
  // regrid
  RecoRegridNFilter RG {outputX = 40; outputY = 40};
 
  // 2D FT
  RecoFTShiftFilter FS1 {winDirection = 0; shift = 0.5};
  RecoFTShiftFilter FS2 {winDirection = 1; shift = 0.5};
  RecoFTFilter F1 {direction = 0; exponent = 1};
  RecoFTFilter F2 {direction = 1; exponent = 1};
  RecoFTShiftFilter FSS1 {winDirection = 0; shift = 0.5};
  RecoFTShiftFilter FSS2 {winDirection = 1; shift = 0.5};
  
  // apodization correction and undo oversampling
  RecoRegridApodCorrFilter AC1 {winDirection = 0; size = 40};
  RecoRegridApodCorrFilter AC2 {winDirection = 1; size = 40};
  RecoCutoffFilter C {sizes = {32, 32}; offset = {4, 4}};
  
  // output
  RecoMaskFilter FOV;
  RecoDummySink S;
  
  QT-&gt;T; T-&gt;DC; DC-&gt;MU; QD-&gt;MU; 
  MU-&gt;RG.data;
  T-&gt;RG.traj;
  RG-&gt;FS1; FS1-&gt;FS2; FS2-&gt;F1; F1-&gt;F2; F2-&gt;FSS1; FSS1-&gt;FSS2;
  FSS2-&gt;C; C-&gt;AC1; AC1-&gt;AC2;
  AC2-&gt;FOV; FOV-&gt;S;
}</pre><p><b> References: </b><br>
</p><ul>
<li>J. Pauly, Non-Cartesian reconstruction, Lectures, October 8, 2007</li>
<li>P.J. Beatty, D.G. Nishimura, J.M. Pauly, Rapid gridding 
reconstruction with a minimal oversampling ratio, IEEE Trans. Med. Imag.
 24 (2005) 799-808</li>
<li>J.I. Jackson, C.H. Meyer, D.G. Nishimura, A. Macovski, Selection of a
 convolution function for Fourier inversion using gridding, IEEE Trans. 
Med. Imag. 10 (1991) 473-478</li>
<li>J.D. O'Sullivan, A fast sinc function gridding algorithm for Fourier
 inversion in computer tomography, IEEE Trans. Med. Imag. 4 (1985) 
200-207</li>
</ul>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoReImFilter"></a>
RecoReImFilter</h1>
<p>Extracts real and/or imaginary data of a complex data stream. Complex
 input data is split into its real and imaginary parts, which are sent 
to named output connectors. If only one of the outputs is connected, the
 other part is discarded.</p>
<p><b> Connectors: </b><br>
 There is one input connector, accepting complex data of any type. There are two named output connectors: </p><ul>
<li>
.R for the real part of the input data </li>
<li>
.I for the imaginary part of the input data </li>
</ul>
<p>A single output or both outputs may be connected.</p>
<p><b>Parameters: </b><br>
 none.</p>
<p><b> Data Stream Requirements:</b><br>
 The filter works on complex input data only.</p>
<p><b> Data Structure Translation: </b><br>
 Output data is real with same data representation.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q;
   RecoPrintFilter P1;
   RecoPrintFilter P2;
   RecoPrintFilter P3;
   RecoReImFilter  R;
   RecoDummySink S1;
   RecoDummySink S2;
   Q-&gt;P1-&gt;R;
   R.R-&gt;P2-&gt;S1;
   R.I-&gt;P3-&gt;S2;
}
// result:
// [0 + i1]
// [0]
// [1]</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoReloadB0Filter"></a>
RecoReloadB0Filter</h1>
<p>The ReloadB0 filter is a hardware synchronizer. This filter 
synchronizes hardware access to set a B0 Value on the hardware. It does 
not change any data but simply copies it to the output.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>B0Value </td><td>Value for B0 unit to be set </td><td>double </td><td>percent </td><td>-100..+100 </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
    RecoDummySource Q;
    RecoPrintFilter P1;
    RecoCopyFilter  C{B0Value=&lt;B0Parameter&gt;};
    RecoPrintFilter P2;
    RecoDummySink   S;
    Q-&gt;P1-&gt;C-&gt;P2-&gt;S;
}
// result:
// [0 + i1]
// [0 + i1] </pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoRemoveFilter"></a>
RecoRemoveFilter</h1>
<p>Shrinks the data array sizes. The filter removes parts of an input 
array along a certain direction. The set of indices that should be 
removed or preserved has to be defined in the parameter indexSet. As 
this indexSet might be calculated during the execution of the RECO 
network, one has to specify the length of indexSet with the parameter 
indexSetSize. Weather the data at the indices has to be removed or 
preserved can be set using the flag remove.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>direction </td><td>direction in which the data is shrunk </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;dim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>indexSet </td><td>data array indices in the given direction to be removed or preserved </td><td>int[] </td><td>none </td><td>0&nbsp;...&nbsp;size[direction]-1 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>indexSetSize </td><td>size of the index set </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;size[direction] </td><td>yes </td><td>-  </td></tr>
<tr>
<td>remove </td><td>If true, indices in indexSet are removed. If false, 
all other indices of the given direction are removed, and the data 
marked by indexSet is preserved. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>true  </td></tr>
<tr>
<td>mask </td><td>If true, the data array size remains unchanged but subblocks are set to zero. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>true * </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 The filter cannot work in place.<br>
</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
    RecoDummySource Q{
    procDim=1;wordSize=8;dataRep=FLOAT;
    baseField=REAL;dim=3;sizes={3,3,2};
        data={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18};
        random=false};
    RecoPrintFilter P;
    RecoRemoveFilter R{direction=1;indexSet={1};indexSetSize=1};
    RecoDummySink S;
    Q-&gt;R;
    R-&gt;P;
    P-&gt;S;
}
// result:
//-------------------------------------------
//[1.00000e+00] [2.00000e+00] [3.00000e+00]
//-------------------------------------------
//-------------------------------------------
//[7.00000e+00] [8.00000e+00] [9.00000e+00]
//-------------------------------------------
//-------------------------------------------
//[1.00000e+01] [1.10000e+01] [1.20000e+01]
//-------------------------------------------
//-------------------------------------------
//[1.60000e+01] [1.70000e+01] [1.80000e+01]
//-------------------------------------------</pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoReverseFilter"></a>
RecoReverseFilter</h1>
<p>Reverses data in every second line. The filter is usually used to 
reverse every second line (direcion 0 in the data array). For example, 
in an EPI experiment, even lines are preserved (0, 2, 4, ...) while odd 
lines are reversed (1, 3, 5, ...). Parameters control whether 
segmentation has to be taken into account.</p>
<p>With segment size = 3, after processing lines 0 to 2, the filter 
restarts counting and line 3 is considered to be an even line again, not
 to be reversed. For 4 points per line, the filter would work as 
follows:</p>
<pre class="fragment">    1 2 3 4 / 5 6 7 8 / 9 10 11 12 / 13 14 15 16 / 17 18 19 20 / 21 22 23 24
 -&gt; 1 2 3 4 / 8 7 6 5 / 9 10 11 12 / 13 14 15 16 / 20 19 18 17 / 24 23 22 11</pre><p>The
 parameter "asymmetric" controls, whether reversal shall take place 
asymmetrically (used for UTE methods), such that the first point is set 
to 0 and reversal is applied only to the remaining data:</p>
<pre class="fragment">    1 2 3 4 5 -&gt; 0 5 4 3 2 </pre><p>By default,
 every second line is reversed. If reverseAll=true is selected, each 
line is reversed. This option is useful in cases, where the data stream 
is split and the reverse filter is applied to odd lines only.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>segment </td><td>Number of lines, after which the counting for 
even/odd lines will re-initialized. Needed to describe segmented or 
interleaved acquisition. If equal to zero, segmentation is off. </td><td>int </td><td>none </td><td>&gt;= 0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>revertAll </td><td>Flag to select every line for reversal, not only every second. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>asymmetric </td><td>Select asymmetric mode, during which the first point will be set to zero </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>blockDim </td><td>dimension of the blocks that are reversed. Note that blockDim=1 corresponds to lines (direction 0 in the data array) </td><td>int </td><td>none </td><td>&gt;= 1 </td><td>no </td><td>1  </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 This filter can work in place.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{baseField=REAL;dim=2;sizes={4,6};offset=1};
   RecoPrintFilter P1;
   RecoReverseFilter R{segment=3};
   RecoPrintFilter P2;
   RecoDummySink S;
   Q-&gt;P1-&gt;R-&gt;P2-&gt;S;
}
// result:
//[1][2][3][4]
//[1][2][3][4]
//[5][6][7][8]
//[8][7][6][5]
//[9][10][11][12]
//[9][10][11][12]
//[13][14][15][16]
//[13][14][15][16]
//[17][18][19][20]
//[20][19][18][17]
//[24][23][22][21]
//[24][23][22][21] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoRGateApplyOrderFilter"></a>
RecoRGateApplyOrderFilter</h1>
<p>Retrospective gating: Applies sorting order. Sorts and interpolates 
the data on each channel according to the sorting table received from <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRGateFindOrderFilter">RecoRGateFindOrderFilter</a>.</p>
<p><b>Connectors: </b><br>
 Two named inputs:</p><ul>
<li>"data" connector</li>
<li>"order" connector: should be connected to the output of <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRGateFindOrderFilter">RecoRGateFindOrderFilter</a>.</li>
</ul>
<p>One output connector, delivering the sorted data.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>nslices </td><td>Number of slices </td><td>int </td><td>none </td><td>&gt;0 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>acqSize </td><td>Number of 2D phase encoding steps </td><td>int </td><td>none </td><td>&gt;0 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>segSize </td><td>Size of segmentation loop  </td><td>int </td><td>none </td><td>&gt;0 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>overs </td><td>Size of the oversampling loop </td><td>int </td><td>none </td><td>&gt;=1 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>movieType </td><td>Defines the type of output movie: cardiac or respiration </td><td>int </td><td>none </td><td>0=cardiac, 1=respiration </td><td>no </td><td>0  </td></tr>
<tr>
<td>movieSize </td><td>Number of movie frames </td><td>int </td><td>none </td><td>&gt;=1 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>cardOnly </td><td>Flag to evaluate only cardiac cycle </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>freezePhase0 </td><td>Defines the gate start point for the first motion (e.g. Heart) </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;1.0 </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>freezePhaseRange0 </td><td>Defines the range of the gating window for the first motion </td><td>double </td><td>none </td><td>&gt;0.0 and &lt;=1.0 </td><td>no </td><td>1.0  </td></tr>
<tr>
<td>freezePhase </td><td>Defines the gate start point for the second motion (e.g. Respiration) </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;1.0 </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>freezePhaseRange </td><td>Defines the range of the gating window for the second motion </td><td>double </td><td>none </td><td>&gt;0.0 and &lt;=1.0 </td><td>no </td><td>1.0  </td></tr>
<tr>
<td>timeGridding </td><td>Flag for time gridding with Gaussian kernel </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>true  </td></tr>
<tr>
<td>GaussWidth </td><td>Defines the width of the Gaussian kernel for time gridding </td><td>double </td><td>none </td><td>&gt;0 and &lt;=movieSize/2 </td><td>no </td><td>1.0  </td></tr>
</tbody></table>
<p><b> Technical Details: </b><br>
 The filter cannot work in place. The filter requires the license feature PVM_IG, as it is specific for IntraGate imaging.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
  // data
  RecoDummySource Q1 
  {
    dim = 2;
    procDim = 2;
    sizes = {1,5};
    dataRep = FLOAT;
    wordSize = 8;
    baseField = COMPLEX;
    data = {1,0,2,0,3,0,4,0,5,0};
  };
  
  // sorting order
  RecoDummySource Q2
  {
    dim=2;
    procDim=2;
    sizes = {2,5}
    dataRep=FLOAT;
    wordSize=8;
    baseField=REAL;
    data={0.9,0,0.7,0,0.5,0,0.3,0,0.1,0};
   };

  RecoRGateApplyOrderFilter A{nslices=1;acqSize=1;segSize=1;overs=5;movieSize=5;timeGridding=false;};        
  RecoPrintFilter P;          
  RecoDummySink S;

  Q1-&gt;A.data;Q2-&gt;A.order;A-&gt;P;P-&gt;S;   

}  
// result:
// [5.00000e+00 + i0.00000e+00] [4.00000e+00 + i0.00000e+00] 
// [3.00000e+00 + i0.00000e+00] [2.00000e+00 + i0.00000e+00] 
// [1.00000e+00 + i0.00000e+00] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoRGateDisplayFilter"></a>
RecoRGateDisplayFilter</h1>
<p>Retrospective gating: Selects data for online display of the navigator time course signal. <b>Connectors:</b><br>
 The filter has two inputs:</p><ul>
<li>"data" connector</li>
<li>"order" connector: should be connected to the output of <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRGateFindOrderFilter">RecoRGateFindOrderFilter</a>.</li>
</ul>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>nslices </td><td>Number of slices </td><td>int </td><td>none </td><td>&gt;0 </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoRGateFindOrderFilter"></a>
RecoRGateFindOrderFilter</h1>
<p>Retrospective gating: Finds sorting order. Reads navigators from all 
inputs, and writes cardiac and respiratory phase of each navigator 
(pairs of numbers from 0.0 to 1.0) to the output. Inputs are typically 
connected to time-domain data, one unnamed input per receive channel, 
while the output is typically connected to the 'order' input of the <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoRGateApplyOrderFilter">RecoRGateApplyOrderFilter</a>.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>cardFrq </td><td>Estimate of cardiac frequency in in units of Nyquist frequency (2/period_in_dwells) </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;1.0 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>respFrq </td><td>Estimate of respiration frequency in in units of Nyquist frequency. </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;1.0 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>cardOnly </td><td>Flag to evaluate only cardiac cycle </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>setupMode </td><td>Flag for setup mode </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>navigMode </td><td>Defines mode of navigator processing. In FID 
mode, the power of the entire navigator is taken; in echo mode, only the
 strongest point. In mixed mode, the strongest point is taken and the 
number of additional points for averaging can be specified. </td><td>int </td><td>none </td><td>0=FID, 1=Echo, 2=mixed </td><td>no </td><td>0  </td></tr>
<tr>
<td>addPoints </td><td>In case of navigMode=2 (mixed mode), addPoints 
specifies the number of additional points which will be averaged 
(starting after the strongest point). </td><td>int </td><td>none </td><td>-  </td><td>no </td><td>0  </td></tr>
<tr>
<td>signalType </td><td>Defines the signal type used for processing: The
 analysis can be performed on the magnitude or phase information of the 
navigator signals. In auto mode the analysis is carried out for both 
(magnitude and phase) and the result with the highest signal-to-noise 
ratio is chosen.  </td><td>int </td><td>none </td><td>0=magnitude, 1=phase, 2=auto </td><td>no </td><td>0  </td></tr>
<tr>
<td>debugFiles </td><td>Flag for generating debug files in directory /tmp/ </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements: </b><br>
 Requires complex, double precision floating point input, and produces real double precision floating point output.</p>
<p><b> Data Structure Translation: </b><br>
 Expects a two-dimensional data block and procDim=2 on each input. All 
inputs must have the same data structure. The output is two-dimensional,
 with sizes [2,inputsize[1]]</p>
<p><b> Technical Details: </b><br>
 This filter cannot work inplace. <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoScaleFilter"></a>
RecoScaleFilter</h1>
<p>Scales input data with a constant real or complex factor and 
optionally applies an offset afterwards. Each input value is multiplied 
with a real-valued scaling factor. This applies to real and complex data
 in the same way.</p>
<p>If the input data is complex, additionally an offset is added to its 
phase. Hence in this case, the data is multiplied by a complex number.</p>
<p>Individual scaling factors can be applied to individual frames. In 
this case, the number of points per frame is determined depending on the
 data descriptor's frameDim property and a number of pointsPerFrame 
points is treated with the same factor.</p>
<p>Furthermore, a constant offset can be added to the data.</p>
<p>See also <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoMapFilter">RecoMapFilter</a>. No overflow checking is performed in this filter.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>scaleFactor </td><td>Multiplication factor which is applied to each value. </td><td>double </td><td>none </td><td>- </td><td>no </td><td>1.0  </td></tr>
<tr>
<td>phaseOffset </td><td>Phase offset which is applied to each complex value. </td><td>double </td><td>deg </td><td>- </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>constOffsetReal </td><td>Constant offset which is applied to the data. In case of complex data, it is only applied to the real part of the data. </td><td>double </td><td>none </td><td>- </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>constOffsetImag </td><td>Constant offset which is applied to imaginary part of the data. In case of real valued data, the parameter is ignored. </td><td>double </td><td>none </td><td>- </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>applyVisuMapping </td><td>scale the input data for each frame 
according to the visu mapping parameters VisuCoreDataSlope and 
VisuCoreDataOffs (output = input * VisuCoreDataSlope + 
VisuCoreDataOffs). This option is only allowed if a visu description is 
available in the data descriptor. </td><td>bool </td><td>none </td><td>true/false </td><td>No </td><td>false  </td></tr>
<tr>
<td>nFrames </td><td>Number of consecutive frames in the datastream, each of which should be modified with individual phase and scaling values. </td><td>int </td><td>none </td><td>- </td><td>no </td><td>1  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The filter supports floating point streams only.</p>
<p><b> Technical Details:</b><br>
 This filter can work inplace.</p>
<p><b> Examples: </b><br>
 </p><pre class="fragment">{
  RecoDummySource Q{dataRep=FLOAT};
  RecoPrintFilter P1;
  RecoScaleFilter SC{scaleFactor=2};
  RecoPrintFilter P2;
  RecoDummySink S;
  Q-&gt;P1-&gt;SC-&gt;P2-&gt;S;
}
// result:
// [0.00000 + i1.00000]
// [0.00000 + i2.00000]


{
  RecoDummySource Q {dataRep=FLOAT; baseField=COMPLEX;};
  RecoPrintFilter P1;
  RecoScaleFilter SC{constOffsetReal=3.14; constOffsetImag=-10;};
  RecoPrintFilter P2;
  RecoDummySink S;
  Q-&gt;P1-&gt;SC-&gt;P2-&gt;S;
}
// result:
// [0.00000e+00 + i1.00000e+00]
// [3.14000e+00 - i9.00000e+00]
</pre><p><br>
</p>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoShuffleProfilesFilter"></a>
RecoShuffleProfilesFilter</h1>
<p>Shuffles profiles from a series of profiles consisting of two blocks.
 A profile is one-dimensional data in the first data dimension. A series
 of profiles consists of two blocks of identical size. The data is 
reordered by putting together the equivalent profiles from each block, 
resulting in one block with twice the profile length and half the number
 of profiles.</p>
<p><b>Parameters:</b><br>
 none.</p>
<p><b> Data Stream Requirements:</b><br>
</p><ul>
<li>One input data stream of dimension = 2.</li>
<li>At least two profiles are required.</li>
</ul>
<p><b> Data Structure Translation: </b><br>
</p><ul>
<li>One output data stream of dimension = 2 (dimension = 1 in case of only two input profiles).</li>
<li>The size of first dimension is doubled.</li>
<li>The size of second dimension is halved.</li>
</ul>
<p><b> Technical Details: </b><br>
 The filter can work inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
  // data
  RecoParameterSource D
  {
    dim         = 2;
    procDim     = 2;
    sizes       = {3, 6};
    dataRep     = FLOAT;
    wordSize    = 8;
    baseField   = REAL;
    data        = {1, 1, 1,
                   2, 2, 2,
                   3, 3, 3,
                   1, 1, 1,
                   2, 2, 2,
                   3, 3, 3};
  };

  // input
  RecoPrintFilter P1{rowsize=3};

  // shuffle
  RecoShuffleProfilesFilter SP;

  // output
  RecoPrintFilter P2{rowsize=6};
  RecoDummySink S;

  D-&gt;P1-&gt;SP;
  SP-&gt;P2-&gt;S;
}
// result
// -------------------------------------------
// [1.00000e+00] [1.00000e+00] [1.00000e+00] 
// [2.00000e+00] [2.00000e+00] [2.00000e+00] 
// [3.00000e+00] [3.00000e+00] [3.00000e+00] 
// [1.00000e+00] [1.00000e+00] [1.00000e+00] 
// [2.00000e+00] [2.00000e+00] [2.00000e+00] 
// [3.00000e+00] [3.00000e+00] [3.00000e+00]
// -------------------------------------------
// [1.00000e+00] [1.00000e+00] [1.00000e+00] [1.00000e+00] [1.00000e+00] [1.00000e+00]
// [2.00000e+00] [2.00000e+00] [2.00000e+00] [2.00000e+00] [2.00000e+00] [2.00000e+00]
// [3.00000e+00] [3.00000e+00] [3.00000e+00] [3.00000e+00] [3.00000e+00] [3.00000e+00]
// -------------------------------------------</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoSincWinMultFilter"></a>
RecoSincWinMultFilter</h1>
<p>Performs window multiplication with a sinc or sinc squared function. 
The SincWinMultFilter implements window multiplication in an arbitrary 
spatial direction with a sinc or sinc squared function parametrized by 
SSB (Sine Bell Shift) and GB. The parameter SSB describes the number of 
complete oscillations while GB defines the position of the maximum 
between the left and right edge: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(t) = \frac{\sin(t)}{t}, t\in [-2\pi {\rm SSB} \cdot {\rm GB},2\pi {\rm SSB} (1-{\rm GB})) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_69.png">
</p>
<p>If the parameter square=true, the window function is: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(t) = \left(\frac{\sin(t)}{t}\right)^2, t\in [-2\pi {\rm SSB} \cdot {\rm GB},2\pi {\rm SSB} (1-{\rm GB})) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_70.png">
</p>
<p>which results in the following graph: </p><div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/SincSquareFilter.png" alt="SincSquareFilter.png">
<div class="caption">
sinc square curve with SSB=2,GB=0</div></div>
<p> <b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>winDirection </td><td>spatial direction for window application </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;procDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>square </td><td>flag to select square or regular sinc function </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>SSB </td><td>Bell shift parameter, specifies the number of oscillations. </td><td>double </td><td>none </td><td>&gt; 0 </td><td>no </td><td>1.0  </td></tr>
<tr>
<td>GB </td><td>Symmetry factor, specifies the position of the maximum. </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;1.0 </td><td>no </td><td>0.0  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 Real and complex floating point input data are supported.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={8};baseField=REAL;dataRep=FLOAT;wordSize=4;
                     constant=true;offset=1};
   RecoSincWinMultFilter W{winDirection=0;SSB=1;GB=0.5};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;W-&gt;P-&gt;S;
}
// result:
// [3.89804e-17] [3.00105e-01] [6.36620e-01] [9.00316e-01]
// [1.00000e+00] [9.00316e-01] [6.36620e-01] [3.00105e-01]
{
   RecoDummySource Q{dim=1;sizes={8};baseField=REAL;dataRep=FLOAT;wordSize=4;
                     constant=true;offset=1};
   RecoSincWinMultFilter W{square=true;winDirection=0;SSB=2;GB=0};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;W-&gt;P-&gt;S;
}
// [1.00000e+00] [4.05285e-01] [1.51947e-33] [4.50316e-02]
// [1.51947e-33] [1.62114e-02] [1.51947e-33] [8.27112e-03]  </pre><p><br>
 <b> References: </b><br>
 topspin commands sinm / qsin <br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoSineWinMultFilter"></a>
RecoSineWinMultFilter</h1>
<p>Performs window multiplication with a sine or sine square function. 
The SineWinMultFilter implements window multiplication in an arbitrary 
spatial direction with a sine or sine squared function parametrized by 
SSB (Sine Bell Shift). The parameter has special meanings: For SSB &lt; 
2, one complete sine lobe from 0 to pi is created. For SSB = 2, a cosine
 half-lobe is created, while for values &gt; 2 the fraction of a sine 
lobe from <img class="formulaInl" alt="$\frac{\pi}{\rm SSB}$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_71.png"> to <img class="formulaInl" alt="$\pi$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_72.png"> is created according to the formula: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(t) = \sin\left(\pi[(1-1/{\rm SSB})t+1/{\rm SSB}]\right), t\in [0,1) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_73.png">
</p>
<p>For SSB=0, the graph of the window function is: </p><div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/SineFilter.png" alt="SineFilter.png">
<div class="caption">
sine curve with SSB=0</div></div>
<p> If the parameter square=true, the window function is: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(t) = \sin\left(\pi[(1-1/{\rm SSB})t+1/{\rm SSB}]\right)^2, t\in [0,1) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_74.png">
</p>
<p>which results in the following graph for SSB=3: </p><div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/SineSquareFilter.png" alt="SineSquareFilter.png">
<div class="caption">
sine square curve with SSB=3</div></div>
<p> <b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>winDirection </td><td>spatial direction for window application </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;procDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>square </td><td>flag to select square or regular sine function </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>SSB </td><td>Bell shift parameter, specifies which fraction of a 
sine bell will be used according to the formula above. Values below 2 
will result in the full sine bell. </td><td>double </td><td>none </td><td>&gt;= 0.0 </td><td>no </td><td>0.0  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 Real and complex floating point input data are supported.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={8};baseField=REAL;dataRep=FLOAT;wordSize=4;
                     constant=true;offset=1};
   RecoSineWinMultFilter W{winDirection=0;SSB=3};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;W-&gt;P-&gt;S;
}
// result:
// [8.66025e-01] [9.65926e-01] [1.00000e+00] [9.65926e-01]
// [8.66025e-01] [7.07107e-01] [5.00000e-01] [2.58819e-01]
{
   RecoDummySource Q{dim=1;sizes={8};baseField=REAL;dataRep=FLOAT;wordSize=4;
                     constant=true;offset=1};
   RecoSineWinMultFilter W{square=true;winDirection=0;SSB=0};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;W-&gt;P-&gt;S;
}

// [0.00000e+00] [1.46447e-01] [5.00000e-01] [8.53553e-01]
// [1.00000e+00] [8.53553e-01] [5.00000e-01] [1.46447e-01] </pre><p><br>
 <b> References: </b><br>
 topspin commands sinm / qsin <br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoSortFilter"></a>
RecoSortFilter</h1>
<p>Sorts interleaved data. This filter is intended to resolve the 
typical sorting of interleaved MRI data, resulting from different phase 
encodings, permutation of lines and segmentation. In addition, sparse 
k-space sampling can be modeled, by sorting input values into an output 
array that is larger than the input, as unoccupied spaces remain zero. 
This can be used, e.g., for parallel imaging, or to implement zero 
filling. However, this filter is <em>not</em> intended to be used to implement zero filling or reordering in the lowest dimension.</p>
<p>For each direction d&gt;0 of the input data array, sortSize[d] points
 are mapped to an output data array, in which the size of direction d is
 sortRange[d], using a mapping defined in sortMaps[]. Before applying 
the sort map, the input data is rearranged to account for segmentation: 
the parameter sortSegment[d] describes how many subsequent blocks of the
 corresponding dimension belong to the same higher dimensional 
direction. The value for the 0th direction corresponds usually to the 
ACQ_phase_factor. No segmentation rearrangement is done for a 
sortSegment entry of 0, while most MR data is interleaved, which means a
 sortSegment entry of 1. See the below example to illustrate the effect 
of mapping and segmenting. </p><div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/SortFilter.png" alt="SortFilter.png">
<div class="caption">
performing 2D mapping</div></div>
<p> <b> Parameters: </b><br>
 Note: Since sorting and zero-filling is only supported in directions 
d&gt;=1, the array parameters do not contain an entry for direction 0.<br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>sortDim </td><td>Dimensions on which sorting is performed. Here, the
 zero (point) dimension is not counted. If sortDim=0, no sorting is 
performed. </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;dim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>sortSize </td><td>Size of the original object for each sort 
dimension. A sortSize entry of 0 is used to indicate that the identity 
map should be used in this dimension. </td><td>int[sortDim-1] </td><td>none </td><td>0 or input&nbsp;sizes[i+1] </td><td>if sortDim&gt;0 </td><td>-  </td></tr>
<tr>
<td>sortRange </td><td>Size of the final object for each sort dimension. Used for the data descriptor of the output stream. </td><td>int[sortDim-1] </td><td>none </td><td>sortRange[i]&gt;=sortSize[i] </td><td>if sortDim&gt;0 </td><td>-  </td></tr>
<tr>
<td>sortMaps </td><td>The sorting maps for all the sorting dimensions 
are concatenated in this array. The length of the array is the sum of 
the sortSizes. The entries must be within the corresponding mapping 
ranges. The maps are assumed to be injective, i.e., no two input lines 
are mapped to the same entry. However, the injectivity condition is not 
checked. </td><td>int[sum(sortSize)-1] </td><td>none </td><td>0&nbsp;...&nbsp;sortRange[i] </td><td>if sum(sortSize)&gt;0 </td><td>-  </td></tr>
<tr>
<td>sortSegment </td><td>For each but the highest dimension, the 
segmentation of the lower dimensions is specified in sortSegment. An 
entry of 0 means, that the data is not segmented but contiguous in this 
dimension. </td><td>int[sortDim-1] </td><td>none </td><td>0&nbsp;...&nbsp;sortSize[i] </td><td>if sortDim&gt;0 </td><td>-  </td></tr>
<tr>
<td>sortMask </td><td>Only use the other sorting parameters up to the 
dimension specified in sortMask, to support low-dimensional setup mode 
with the same parameters. The default value 0 means that no masking is 
performed. </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;sortDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>frameDim </td><td>new frame dimension for output data stream </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;dim </td><td>no </td><td>input frameDim  </td></tr>
</tbody></table>
<p><b> Data Structure Translation: </b><br>
 The data sizes are changed according to the specified sortRanges. The output procDim will be set to sortDim+1.</p>
<p><b> Technical Details: </b><br>
 This filter cannot operate inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">// sorting in 2 directions with zero filling
{
   RecoDummySource Q{
        procDim=1;wordSize=2;dataRep=UNSIGNED;
        baseField=REAL;dim=3;sizes={1,4,3}};
   RecoSortFilter F{
        sortDim=2;
        sortMaps={2,1,0,3,  // map in 1st direction
                  1,0,2};   // map in 2nd direction
        sortSize={4,3};
        sortRange={5,3};
        sortSegment={2,0};
        };
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;F;
   F-&gt;P;
   P-&gt;S;
}
// result:
// [8] [3] [2] [9] [0] [6] [1] [0] [7] [0] [10] [5] [4] [11] [0] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoSpectCorrFilter"></a>
RecoSpectCorrFilter</h1>
<p>Performs corrections on the phase of spectroscopic FID data. Corrections are:</p><ul>
<li>Eddy current compensation (EDC): A reference scan can be passed (as 
parameter) from which the waterline phase evolution is determined. This 
phase evolution is subtracted from each FID.</li>
<li>Retro Frequency Lock (RFL): a navigator scan can be connected as 
second input. From this navigator, a phase drift is determined (compared
 to the very first scan) and subtracted from the corresponding FID.</li>
</ul>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>useNav </td><td>activate retro frequency lock using the navigator </td><td>bool </td><td>none </td><td>- </td><td>no </td><td>false  </td></tr>
<tr>
<td>relNavBw </td><td>navigator acquisition bandwidth relative to spectrum bandwidth </td><td>double </td><td>none </td><td>[0.0,...[ </td><td>no </td><td>1.0  </td></tr>
<tr>
<td>refcor </td><td>activate eddy current compensation using the reference scan data </td><td>bool </td><td>none </td><td>- </td><td>no </td><td>false  </td></tr>
<tr>
<td>refData </td><td>Array parameter containing the reference scan data </td><td>int </td><td>- </td><td>re/im pairs </td><td>- </td><td>-  </td></tr>
<tr>
<td>refPoint </td><td>Reference point at which the phase is assumed to be 0 </td><td>double </td><td>points </td><td>both positive and negative non-integer values allowed. </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>digShift </td><td>Number of points shifted by digital filter in FID. No drift compensation is performed for these points. </td><td>double </td><td>points </td><td>- </td><td>no </td><td>0  </td></tr>
<tr>
<td>filterWidth </td><td>Width (in points) of the gaussian filter that 
is applied to select the water line for eddy current compensation. 0 
means automatic determination. </td><td>int </td><td>points </td><td>- </td><td>no </td><td>0  </td></tr>
</tbody></table>
<p><b>Data Stream Requirements</b><br>
 This filter works on complex, double precision floating point data only.</p>
<p><b>Technical Details:</b><br>
 This filter does not operate inplace.</p>
<p><b> Example: </b><br>
</p>
<pre class="fragment">{
      char spectCorrOptions[400];
      int nrReceivers  = RecoNrActiveReceivers();
      
      for (int i = 0; i &lt; nrReceivers; i++)
      {
        sprintf(spectCorrOptions,
                "useNav = %d;"
                "refPoint = %f;"
                "digShift = %f;"
                "refcor = %d;"
                "refData = &lt;PVM_RefScan[%d]&gt;;"
                "filterWidth = %f;"
                "relNavBw = %f",
                (RetroFrequencyLock_OnOff == On) ? 1:0,
                (RetroFrequencyLock_OnOff==On)?effDigShift:0,
                effDigShift,
                (Edc_OnOff == On) ? 1:0,
                i,
                EdcFilterWidth,
                PVM_NavSWh/PVM_SpecSWH[0]);
        RecoComputeAppendStage(RECOFIRSTPASS,i,"CAST","RecoSpectCorrFilter","SPECTCORR",spectCorrOptions);
      }
}</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoSplitFilter"></a>
RecoSplitFilter</h1>
<p>Allows splitting up an input stream into separate output streams. An 
input stream is split up into multiple symmetric output streams. The 
size of the packages to be distributed to the individual output streams 
is described by the parameters dim and blockCnt which describe the 
number of subsequent blocks of dim, which will be output to the same 
connector. The parameter keepBlocksize can be used to decide whether the
 description of the output streams will reduce the rank of the output 
blocks. For example, a 2x4x2 dataset may be split either into two 4x2 or
 two 2x2x2 datasets, if the splitting dimension is dim=1. For details on
 data structure translation, see below.</p>
<p><b> Connectors: </b><br>
 This filter supports up to 32 unnamed output connectors. The data 
blocks are transferred to the outputs in the order in which they were 
connected.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>dim </td><td>dimension of blocks which are split </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;input&nbsp;dim </td><td>no </td><td>procDim  </td></tr>
<tr>
<td>blockCnt </td><td>Number of subsequent blocks which will be transferred to the same output. </td><td>int </td><td>none </td><td>1&nbsp;...&nbsp;size(dim) </td><td>no </td><td>1  </td></tr>
<tr>
<td>keepBlocksize </td><td>Flag to control data description translation. </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The input data size must be divisible by the number of connectors and by blockCount in the relevant dimension.</p>
<p><b> Data Structure Translation: </b><br>
 If keepBlocksize=true, output size(dim) = input size(dim) / number of 
connectors. If keepBlocksize=false, output size(dim-1) = input 
size(dim-1) / number of connectors. In both cases, if the resulting size
 in reduced direction is 1, that direction is removed from the output 
data description.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
    RecoDummySource Q{dim=3;sizes={2,4,2};dataRep=SIGNED;wordSize=4;
                       baseField=REAL;procDim=2;};
    RecoSplitFilter Sp{dim=1;blockCnt=2;keepBlocksize=true};
    RecoPrintFilter P1{verbose=true;};
    RecoPrintFilter P2{verbose=true;};
    RecoDummySink S1{verbose=true};
    RecoDummySink S2{verbose=true};
    Q-&gt;Sp;
    Sp-&gt;P1-&gt;S1;
    Sp-&gt;P2-&gt;S2;
}
{
    RecoDummySource Q{dim=3;sizes={2,4,2};dataRep=SIGNED;wordSize=4;
                       baseField=REAL;procDim=2;};
    RecoSplitFilter Sp{dim=1;blockCnt=2;keepBlocksize=false};
    RecoPrintFilter P1{verbose=true;};
    RecoPrintFilter P2{verbose=true;};
    RecoDummySink S1{verbose=true};
    RecoDummySink S2{verbose=true};
    Q-&gt;Sp;
    Sp-&gt;P1-&gt;S1;
    Sp-&gt;P2-&gt;S2;
}
// Result:
// Sink&lt;S1&gt; ...
// procDimension:      2
// 2 2 2
//
// Sink&lt;S2&gt; ...
// procDimension:      2
// 2 2 2
//
// &gt;&gt;&gt;&gt; Filter&lt;P1&gt;: [0] [1] [4] [5]
// &gt;&gt;&gt;&gt; Filter&lt;P2&gt;: [2] [3] [6] [7]
// &gt;&gt;&gt;&gt; Filter&lt;P1&gt;: [8] [9] [12] [13]
// &gt;&gt;&gt;&gt; Filter&lt;P2&gt;: [10] [11] [14] [15]
//
//  Sink&lt;S1&gt; ...
// procDimension:      2
// 4 2
//
// Sink&lt;S2&gt;
// procDimension:      2
// 4 2
//
// &gt;&gt;&gt;&gt; Filter&lt;P1&gt;: [0] [1] [4] [5]
// &gt;&gt;&gt;&gt; Filter&lt;P2&gt;: [2] [3] [6] [7]
// &gt;&gt;&gt;&gt; Filter&lt;P1&gt;: [8] [9] [12] [13]
// &gt;&gt;&gt;&gt; Filter&lt;P2&gt;: [10] [11] [14] [15] </pre><p><br>
</p>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoSquareRootFilter"></a>
RecoSquareRootFilter</h1>
<p>Calculates the square root of non-negative real input data. This 
filter determines the square root of real, floating point input data. No
 check for the sign of the input data is currently performed for reasons
 of efficiency, i.e., negative input data will produce a nan 
(not-a-number) result. If subsequent filters cannot handle this, the 
square root filter should be preceeded by a magnitude filter.</p>
<p><b>Parameters: </b><br>
 none.</p>
<p><b> Data Stream Requirements:</b><br>
 The filter operates on real floating point data only, i.e., baseField = REAL, dataRep = FLOAT.</p>
<p><b> Technical Details:</b><br>
 This filter can work inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={4};dataRep=FLOAT;baseField=REAL;
                     data={1.0,2.0,4.0,-1.0};};
   RecoPrintFilter P1;
   RecoSquareRootFilter W;
   RecoPrintFilter P2;
   RecoDummySink S;
   Q-&gt;P1-&gt;W-&gt;P2-&gt;S;
}
// result:
// [1.00000e+00][2.00000e+00][4.00000e+00][-1.00000e+00]
// [1.00000e+00][1.41421e+00][2.00000e+00][nan] </pre><p><br>
 <b> References: </b><br>
 man 3 sqrt <br>
  <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoSquareWinMultFilter"></a>
RecoSquareWinMultFilter</h1>
<p>Performs window multiplication with a square (boxcar) function. This 
filter defines a window function with values 1.0 between TM1 and TM2 and
 0.0 elsewhere. It can be used to set the beginning and end of a data 
area to zero.</p>
<p>Truncation is used to determine the discrete positions of the 
transitions from 0 to 1. For example, for 8 points a value of TM1 = 
0.499 will set the first 3 points to 0 while TM1 = 0.5 will set the 
first 4 points to 0.</p>
<p>Graph of the boxcar window function: </p><div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/SquareFilter.png" alt="SquareFilter.png">
<div class="caption">
Square Win Mult Filter</div></div>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>winDirection </td><td>spatial direction for window application </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;procDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>TM1 </td><td>relative left edge of plateau </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;TM2 </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>TM2 </td><td>relative right edge of plateau </td><td>double </td><td>none </td><td>TM1&nbsp;...&nbsp;1.0 </td><td>no </td><td>1.0  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The filter operates on real and complex floating point data.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={8};dataRep=FLOAT;wordSize=4;baseField=REAL;
                     constant=true;offset=1;};
   RecoSquareWinMultFilter W{TM1=0.25;TM2=0.75};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;W-&gt;P-&gt;S;
}
// result:
// [0.00000e+00] [0.00000e+00] [1.00000e+00] [1.00000e+00]
// [1.00000e+00] [1.00000e+00] [0.00000e+00] [0.00000e+00] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoStabCorrFilter"></a>
RecoStabCorrFilter</h1>
<p>Extracts navigator information. This filter extracts navigator 
information from a long scan, splits it into smaller scans and uses 
navigator information to calculate corrections.</p>
<p>Corrections are:</p><ul>
<li>With drift correction, zero- and first-order phase alignment with the first scan.</li>
<li>Without drift correction: amplitude and zero-order phase alignment with first segment of a segmented scan.</li>
</ul>
<p>Both cases work separately for each slice.</p>
<p><b>Data Stream Requirements:</b><br>
 This filter works on complex, double precision floating point data only.</p>
<p><b>Technical Details:</b><br>
 This filter does not work inplace. <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoSumOfSquaresFilter"></a>
RecoSumOfSquaresFilter</h1>
<p>Combines the input streams by calculating the root of the sum of 
squares. The filter performs a sum-of-squares combination of its real or
 complex input streams. For n real inputs <img class="formulaInl" alt="$ x_i $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_75.png">, the result is <img class="formulaInl" alt="$ x_o = \sqrt{x_1^2 + \ldots + x_n^2} $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_76.png">, for n complex inputs <img class="formulaInl" alt="$ z_i $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_77.png">, the result is <img class="formulaInl" alt="$ x_o = \sqrt{z_1\bar z_1 + \ldots + z_n\bar z_n} $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_78.png">.</p>
<p><b> Connectors: </b><br>
 The filter requires between one and 32 inputs and has a single output. 
In case of a single input, the output consists of the absolute value of 
the input data. As the sum of squares is commutative, inputs are not 
named and the order of the inputs is not relevant.</p>
<p><b> Parameters:</b><br>
 none.</p>
<p><b> Data Stream Requirements:</b><br>
 The filter operates on real or complex, double precision floating point
 input data. The output values are always real, in double precision 
floating point format. The data structure must be identical for all 
inputs.</p>
<p><b>Technical Details:</b><br>
 This filter cannot work inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q1{dim=1;sizes={2};dataRep=FLOAT;wordSize=8;baseField=REAL;
                      data={1.0, 2.0};};
   RecoDummySource Q2{dim=1;sizes={2};dataRep=FLOAT;wordSize=8;baseField=REAL;
                      data={1.0, 0.0};};
   RecoPrintFilter P;
   RecoSumOfSquaresFilter A;
   RecoDummySink S;
   Q1-&gt;A;Q2-&gt;A;A-&gt;P-&gt;S;
}
// result:
// [1.41421e+00][2.00000e+00]</pre><p><br>
  <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoTeeFilter"></a>
RecoTeeFilter</h1>
<p>Duplicates data from a single input stream to multiple output 
streams. The Tee filter has similar functionality like the UNIX tee 
shell command, which replicates a single input stream to multiple output
 streams. Tee filters can be used to implement a fanout behavior. They 
are useful for debugging purposes, when e.g. data should be observed 
after performing certain transformations.</p>
<p><b>Connectors:</b><br>
 This filter supports 2 to 1024 output connectors, which receive copies of the data from the (single) input.</p>
<p><b>Parameters:</b><br>
 none.</p>
<p><b> Data Stream Requirements: </b><br>
 This filter supports any type of input data stream.</p>
<p><b> Data Structure Translation: </b><br>
 All output data streams inherit the description of the input data.</p>
<p><b> Technical Details: </b><br>
 The filter works inplace for one of the output streams.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
      RecoDummySource Q;
      RecoPrintFilter P;
      RecoTeeFilter   T;
      RecoPrintFilter P1;
      RecoPrintFilter P2;
      RecoPrintFilter P3;
      RecoDummySink   S1;
      RecoDummySink   S2;
      RecoDummySink   S3;
      Q-&gt;P-&gt;T; T-&gt;P1-&gt;S1; T-&gt;P2-&gt;S2; T-&gt;P3-&gt;S3;
}
// result:
// [0 + i1]
// [0 + i1]
// [0 + i1]
// [0 + i1]</pre><p> <br>
 <b> References: </b><br>
 man tee <br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoTraficWinMultFilter"></a>
RecoTraficWinMultFilter</h1>
<p>Performs window multiplication with a so-called Traficante function. 
The Traficante window is parametrized by the line broadening factor LB 
and the sweep width SW and reads </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(t)= \frac{e^{\alpha t}}{e^{2\alpha t} + e^{2(1-\alpha)t}} \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_79.png">
</p>
<p> where <img class="formulaInl" alt="$t \in [0,1)$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_80.png"> and <img class="formulaInl" alt="$ \alpha = -\frac{\pi}{2}\,n\,\frac{\rm LB}{\rm SW}$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_81.png"> and n equals the number of sampling points.</p>
<div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/Traficante.png" alt="Traficante.png">
<div class="caption">
Traficante windowing function for LB=0.0, SW=1.0</div></div>
<p> When the square flag is set, the function changes to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ f(t)= \frac{e^{\alpha t}}{e^{2\alpha t} + e^{2(1-\alpha)t}} \left(e^{ \alpha t} + e^{(1-\alpha)t} \right) \]" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_82.png">
</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>winDirection </td><td>spatial direction for window application </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;procDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>square </td><td>square mode flag </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>false  </td></tr>
<tr>
<td>LB </td><td>line broadening factor </td><td>double </td><td>Hz </td><td>- </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>SW </td><td>sweep width </td><td>double </td><td>Hz </td><td>- </td><td>no </td><td>1.0  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 Real and complex floating point input data are supported.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">@verbatim
{
   RecoDummySource Q{dim=1;sizes={8};baseField=REAL;dataRep=FLOAT;wordSize=4;
                     constant=true;offset=1};
   RecoTraficWinMultFilter W{winDirection=0;LB=1;SW=8};
   RecoPrintFilter P;
   RecoDummySink S;
   Q-&gt;W-&gt;P-&gt;S;
}
// result:
// [9.58576e-01] [1.11159e+00] [1.22609e+00] [1.23788e+00]
// [1.09664e+00] [8.35854e-01] [5.59023e-01] [3.42220e-01]</pre><p><br>
 <b> References: </b><br>
 D. D. Traficante, G. A. Nemeth, J. Magn. Reson., 71, 237-245 (1987)<br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoTrajectoryFilter"></a>
RecoTrajectoryFilter</h1>
<p>Calculates k-space trajectory from dedicated data. In k-space 
trajectory measurements, a gradient shape is applied in one dimension at
 a time and recorded at off-centered locations in the same dimension. 
This can be accomplished by using micro-coils or spatially selective 
excitation. From the obtained data, this filter extracts spatially 
linear and constant terms for each time point, representing the k-space 
trajectory as well as B0 off-resonances due to eddy currents, 
respectively.</p>
<p><b>Parameters:</b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit</th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>nDims </td><td>number of dimensions </td><td>unsigned int </td><td>- </td><td>1&nbsp;...&nbsp;3 </td><td>no </td><td>1  </td></tr>
<tr>
<td>nInterleaves </td><td>number of interleaves, i.e. separate parts of a trajectory </td><td>unsigned int </td><td>- </td><td>&gt; 0 </td><td>no </td><td>1  </td></tr>
<tr>
<td>junk </td><td>number of initial samples to be skipped for each data line </td><td>unsigned int </td><td>complex samples </td><td>&gt;= 0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>scaleK </td><td>determines scaling of the trajectory values for each dimension:<ul>
<li>If scaleK=1/(slice offset [mm]): <img class="formulaInl" alt="$k$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_59.png"> is in units [1/mm] with <img class="formulaInl" alt="$k_{max}$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_93.png"> = 1 / (2*resolution [mm]).</li>
<li>If scaleK=resolution [mm]/(slice offset [mm]): <img class="formulaInl" alt="$k$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_59.png"> is normalized with <img class="formulaInl" alt="$k_{max}$" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_93.png"> = 0.5.  </li>
</ul>
</td><td>double[nDims] </td><td>- </td><td>&gt; 0 </td><td>yes </td><td>-  </td></tr>
<tr>
<td>kx </td><td>(output parameter) Trajectory for first dimension </td><td>double[nInterleaves * size] </td><td>1/mm or normalized (see scaleK) </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>ky </td><td>(output parameter) Trajectory for second dimension </td><td>double[nInterleaves * size] </td><td>1/mm or normalized (see scaleK) </td><td>- </td><td>if nDim&gt;=2 </td><td>-  </td></tr>
<tr>
<td>kz </td><td>(output parameter) Trajectory for third dimension </td><td>double[nInterleaves * size] </td><td>1/mm or normalized (see scaleK) </td><td>- </td><td>if nDim=3 </td><td>-  </td></tr>
<tr>
<td>bx </td><td>(output parameter) B0 phase for first dimension </td><td>double[nInterleaves * size] </td><td>rad </td><td>- </td><td>yes </td><td>-  </td></tr>
<tr>
<td>by </td><td>(output parameter) B0 phase for second dimension </td><td>double[nInterleaves * size] </td><td>rad </td><td>- </td><td>if nDim&gt;=2 </td><td>-  </td></tr>
<tr>
<td>bz </td><td>(output parameter) B0 phase for third dimension </td><td>double[nInterleaves * size] </td><td>rad </td><td>- </td><td>if nDim=3 </td><td>-  </td></tr>
<tr>
<td>outputType </td><td>type of filter output </td><td>unsigned int </td><td>- </td><td>possible settings:<br>
 0: trajectory<br>
 1: gradient<br>
 2: gradient spectrum<br>
 3: frequency response (requires input gradients gx, gy, gz) </td><td>no </td><td>0  </td></tr>
<tr>
<td>dwell </td><td>acquisition dwell time: duration of sampling interval </td><td>double </td><td>ms </td><td>&gt; 0 </td><td>if input gradients are provided </td><td>-  </td></tr>
<tr>
<td>gx </td><td>input gradient for first dimension </td><td>double[nInterleaves * size] </td><td>kHz/mm or kHz </td><td>- </td><td>if outputType=3 </td><td>-  </td></tr>
<tr>
<td>gy </td><td>input gradient for second dimension </td><td>double[nInterleaves * size] </td><td>kHz/mm or kHz </td><td>- </td><td>if outputType=3 and nDim&gt;=2 </td><td>-  </td></tr>
<tr>
<td>gz </td><td>input gradient for third dimension </td><td>double[nInterleaves * size] </td><td>kHz/mm or kHz </td><td>- </td><td>if outputType=3 and nDim=3 </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 This filter supports complex, double precision floating point input data of any dimension. The loop order from in to out is:</p><ul>
<li>locations (2, positive offset first)</li>
<li>interleaves (reference first)</li>
<li>dimensions</li>
</ul>
<p>For each location, a reference without application of a gradient is 
provided in addition as the first scan of a series. Hence, the total 
number of lines is 2 * (nInterleaves + 1) * nDims.</p>
<p>The first dimension holds all samples for one data line. The second 
dimension holds all lines. Multiple channels are combined with 
appropriate weighting to provide one trajectory.</p>
<p><b> Data Structure Translation: </b><br>
 The output data is complex-valued trajectory data for each interleave 
and dimension: The real part contains the measured result or the 
response, the imaginary part contains the corresponding theoretical 
values if provided and applicable, and is otherwise zero. The size of 
the first output dimension is equal to input size[0] - junk. The size of
 the second output dimension is equal to nInterleaves * nDims.</p>
<p><b> Technical Details: </b><br>
 The filter does not work inplace.</p>
<p><b> References: </b><br>
</p><ul>
<li>Duyn JH, Yang Y, Frank JA, van der Veen JW, Simple correction method
 for k-space trajectory deviations in MRI, JMR 132 (1998) 150-153</li>
<li>Zhang Y, Hetherington HP, Stokely EM, Mason GF, Twieg DB, A novel 
k-space trajectory measurement technique, MRM 39 (1998) 999-1004</li>
<li>Boernert P, Schomberg H, Aldefeld B, Groen J, Improvements in spiral MR imaging, MAGMA 9 (1999) 29-41</li>
</ul>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoTransposeFilter"></a>
RecoTransposeFilter</h1>
<p>Performs a transposition of coordinate directions, i.e., mirroring of
 an array along a diagonal. This filter supports the transposition of 
two subsequent or the first and last coordinate directions. The 
parameter "transpose" defines transposition directions as follows: 
Transposition direction 0 means the identity map, transposition 
direction 1 interchanges the first two directions, transposition 
direction 2 interchanges the second and third direction and so on. If 
the transposition direction equals the frame dimension, the first and 
last direction are interchanged. The frame dimension is read from the 
input data descriptor.</p>
<p>For each frame in a repetition, the transpose parameter can contain a
 separate entry. If there are less entries than frames in a repetition, 
the list is used cyclically. If the entries per frame are different, the
 sizes in the directions to be interchanged must be equal.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>transpose </td><td>Transposition for each frame of repetition </td><td>int[] </td><td>none </td><td>0&nbsp;...&nbsp;dim </td><td>yes </td><td>1  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 procDim &gt;= dimension is necessary <br>
</p>
<p><b> Data Structure Translation: </b><br>
 size[transpose%frameDim] is interchanged with size[transpose-1].</p>
<p><b> Technical Details: </b><br>
 The filter can operate inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{procDim=2;frameDim=2;dim=3;sizes={3,3,3};baseField=REAL;};
   RecoTransposeFilter T{transpose={1,0};};
   RecoPrintFilter P{rowsize=3;};
   RecoPrintFilter Pt{rowsize=3;};
   RecoDummySink S;
   Q-&gt;P-&gt;T-&gt;Pt-&gt;S;
}
// result 
-------------------------------------------
[0] [1] [2] 
[3] [4] [5] 
[6] [7] [8] 

[0] [3] [6] 
[1] [4] [7] 
[2] [5] [8] 
-------------------------------------------
[9] [10] [11] 
[12] [13] [14] 
[15] [16] [17] 

[9] [10] [11] 
[12] [13] [14] 
[15] [16] [17] 
-------------------------------------------
[18] [19] [20] 
[21] [22] [23] 
[24] [25] [26] 

[18] [21] [24] 
[19] [22] [25] 
[20] [23] [26] 
-------------------------------------------
</pre><p><br>
</p>
<p><br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoTrapezWinMultFilter"></a>
RecoTrapezWinMultFilter</h1>
<p>Performs window multiplication with a trapezoidal window function. 
The trapezoidal window is described by two parameters TM1 and TM2 which 
define the plateau of the trapezoid in the interval [0,1].</p>
<div class="image">
<img src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/RecoTrapezWin.png" alt="RecoTrapezWin.png">
</div>
<p><b> Parameters: </b><br>
</p>
<table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>winDirection </td><td>spatial direction for window application </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;procDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>TM1 </td><td>Relative left edge of plateau </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;TM2 </td><td>no </td><td>0.0  </td></tr>
<tr>
<td>TM2 </td><td>Relative right edge of plateau </td><td>double </td><td>none </td><td>TM1&nbsp;...&nbsp;1.0 </td><td>no </td><td>1.0  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 Real and complex floating point input data are supported.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={8};dataRep=FLOAT;wordSize=4;baseField=REAL;
                     constant=true;offset=1};
   RecoTrapezWinMultFilter W{TM1=0.25; TM2=0.75};
   RecoPrintFilter P{rowsize=4};
   RecoDummySink S;
   Q-&gt;W-&gt;P-&gt;S;
}
// result:
// [0.00000e+00] [5.00000e-01] [1.00000e+00] [1.00000e+00]
// [1.00000e+00] [1.00000e+00] [1.00000e+00] [5.00000e-01] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoUnwrapFilter"></a>
RecoUnwrapFilter</h1>
<p>Multidimensional phase unwrapping with optional mask. Unwraps a phase
 map in several iterations, treating noisy regions last. Supports 2D and
 3D phase maps and an optional mask of pixels to be unwrapped.</p>
<p><b> Connectors:</b><br>
 This filter has two named input connectors: </p><ol>
<li>
Connector "data": Phase data to be unwrapped. </li>
<li>
Connector "mask" (optional): Mask defining which voxels the algorithm 
processes. Must be real, signed char format and must have the same size 
as the data.  </li>
</ol>
<p>There is one output connector, providing the unwrapped data.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>seedPointX </td><td>Start flooding from this voxel (x coordinate) </td><td>int </td><td>none </td><td>&gt;=0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>seedPointY </td><td>Start flooding from this voxel (y coordinate) </td><td>int </td><td>none </td><td>&gt;=0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>seedPointZ </td><td>Start flooding from this voxel (z coordinate) </td><td>int </td><td>none </td><td>&gt;=0 </td><td>no </td><td>0  </td></tr>
<tr>
<td>phaseWrap </td><td>Defines phase wrap to be unwrapped. All adjacent 
voxels having an absolute phase difference greater than phaseWrap are 
going to be unwrapped. </td><td>double </td><td>none </td><td>&gt;0.0 </td><td>no </td><td>pi=3.1415...  </td></tr>
<tr>
<td>noiseBlur </td><td>Kernel size for blurring estimated noise map. </td><td>int </td><td>none </td><td></td><td>no </td><td>5  </td></tr>
<tr>
<td>thresIter </td><td>Number of noise threshold iterations </td><td>int </td><td>none </td><td></td><td>no </td><td>10  </td></tr>
<tr>
<td>thresMax </td><td>Iterate up to maximum noise level </td><td>double </td><td>none </td><td></td><td>no </td><td>100  </td></tr>
<tr>
<td>signalRatio </td><td>Return a warning, if the ratio of voxels that could be processed to the total number of voxels is less than signalRatio. </td><td>double </td><td>none </td><td>0.0&nbsp;...&nbsp;1.0 </td><td>no </td><td>0.2  </td></tr>
</tbody></table>
<p>If all three seed point values are set to 0, a seed point is searched
 automatically. If no mask input is connected, all voxels are processed.</p>
<p><b>Technical Details:</b><br>
 The filter cannot work in place. The filter does not need context.</p>
<p><b>Data Stream Requirements:</b><br>
 The filter supports only real, double precision floating point data. <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoUserWinMultFilter"></a>
RecoUserWinMultFilter</h1>
<p>Performs windowing with an arbitrary windowing function. This filter 
performs windowing of data with an arbitrary real function, which is 
specified in the parameter "winFunction". The winFunction is defined by a
 one-dimensional array of integers (for compatibility to existing 
parameters). Internally, before multiplication with the data, the 
individual values are rescaled to floating point format, according to 
[-MAXINT, MAXINT] <img class="formulaInl" alt="$ \rightarrow $" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/form_42.png"> [-1.0, 1.0].</p>
<p>To achieve maximum dynamic range, you should therefore use large integers in winFunction.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>winDirection </td><td>direction in which windowing is performed </td><td>int </td><td>none </td><td>0&nbsp;...&nbsp;procDim-1 </td><td>no </td><td>0  </td></tr>
<tr>
<td>winFunction </td><td>windowing function as integer array. The size of the array must match the data size in the selected windowing direction. </td><td>int[] </td><td>none </td><td>- </td><td>yes </td><td>-  </td></tr>
</tbody></table>
<p><b> Data Stream Requirements:</b><br>
 The windowing function operates on arbitrary floating point streams 
(real and complex, single and double precision). The processing 
dimension must be suitable for the selected windowing direction.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{
   RecoDummySource Q{dim=1;sizes={4};dataRep=FLOAT;wordSize=4;baseField=COMPLEX;
                     offset=2147483647;constant=true};
   RecoUserWinMultFilter W{winFunction={ 0, 2, 1, 3};};
   RecoPrintFilter P{format="%2.2f"};
   RecoDummySink S;
   Q-&gt;W-&gt;P-&gt;S;
}
// result:
// [0.00 + i0.00][2.00 + i2.00][1.00 + i1.00][3.00 + i3.00] </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoVarianceFilter"></a>
RecoVarianceFilter</h1>
<p>Computes the variance. This filter computes the variance of input 
data in the first direction. If the data are complex, the variance of 
the absolute value is calculated.</p>
<p><b>Parameters:</b><br>
 none.</p>
<p><b> Data Stream Requirements:</b><br>
 This filter supports real and complex data, in double precision 
floating point format. The input data stream must be of dimension &lt;= 
2.</p>
<p><b> Data Structure Translation: </b><br>
 There is one output stream, in which the size of the first dimension is equal to 1. The output data is real.</p>
<p><b> Technical Details: </b><br>
 The filter does not work inplace.</p>
<p><b>Example:</b> </p><pre class="fragment">{
    RecoDummySource Q{
    procDim=2;wordSize=8;dataRep=FLOAT;
    baseField=COMPLEX;dim=2;sizes={5,2};data={1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10};random=false};
    RecoPrintFilter P1{format="%4.2f";};
    RecoPrintFilter P2{format="%4.2f";};
    RecoVarianceFilter M{};
    RecoDummySink S;
    Q-&gt;P1;
    P1-&gt;M;
    M-&gt;P2;
    P2-&gt;S;
}
// result
//
// -------------------------------------------
// [1.00 + i1.00] [2.00 + i2.00] [3.00 + i3.00] [4.00 + i4.00] [5.00 + i5.00] [6.00 + i6.00] [7.00 + i7.00] [8.00 + i8.00] [9.00 + i9.00] [10.00 + i10.00] 
// -------------------------------------------
// -------------------------------------------
// [5.00] [5.00] 
// -------------------------------------------</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoWeightingFilter"></a>
RecoWeightingFilter</h1>
<p>Weights a 2D-Matrix line-by-line. This filter multiplies each line of
 a two-dimensional input data matrix by an individual weighting factor.</p>
<p><b>Parameters:</b><br>
 none.</p>
<p><b> Connectors:</b><br>
 Input data streams:</p><ul>
<li>.data: Data with dimension = 2</li>
<li>.weight: weighting factors, dimension = 1</li>
</ul>
<p><b> Data Stream Requirements:</b><br>
 The second dimension of the data input must match the first dimension 
of the weight input. This filter supports real and complex data, whereas
 the weights must be real. All values must be in double precision 
floating point format.</p>
<p><b> Data Structure Translation: </b><br>
 One output data stream with the same structure as the data input.</p>
<p><b> Technical Details: </b><br>
 The filter does not work inplace.</p>
<pre class="fragment">// RecoWeightingFilter01
{
    RecoDummySource Data{
    procDim=1;wordSize=8;dataRep=FLOAT;
    baseField=COMPLEX;dim=2;sizes={5,2};data={1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10};random=false};
    RecoDummySource Weight{
    procDim=1;wordSize=8;dataRep=FLOAT;
    baseField=REAL;dim=1;sizes={2};data={-1,2};random=false};
    RecoPrintFilter P1{format="%4.1f";};
    RecoPrintFilter P2{format="%4.1f";};
    RecoPrintFilter P3{format="%4.1f";};
    RecoWeightingFilter W{};
    RecoDummySink S;
    Data-&gt;P1;
    Weight-&gt;P2;
    P1-&gt;W.data;
    P2-&gt;W.weight;
    W.weightedData-&gt;P3;
    P3-&gt;S;
}
// result
//
// 
// -------------------------------------------
// [ 1.0 + i 2.0] [ 3.0 + i 4.0] [ 5.0 + i 6.0] [ 7.0 + i 8.0] [ 9.0 + i10.0] 
// -------------------------------------------
// -------------------------------------------
// [-1.0] 
// -------------------------------------------
// -------------------------------------------
// [-1.0 - i 2.0] [-3.0 - i 4.0] [-5.0 - i 6.0] [-7.0 - i 8.0] [-9.0 - i10.0] 
// -------------------------------------------
// -------------------------------------------
// [ 2.0] 
// -------------------------------------------
// -------------------------------------------
// [ 1.0 + i 2.0] [ 3.0 + i 4.0] [ 5.0 + i 6.0] [ 7.0 + i 8.0] [ 9.0 + i10.0] 
// -------------------------------------------
// -------------------------------------------
// [ 2.0 + i 4.0] [ 6.0 + i 8.0] [10.0 + i12.0] [14.0 + i16.0] [18.0 + i20.0] 
// -------------------------------------------</pre><p> <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 <h1><a class="anchor" id="RecoZfillFilter"></a>
RecoZfillFilter</h1>
<p>Inserts zero values into a data stream. This filter performs zero 
filling in the first (spatial) direction. Zero filling in higher 
dimensions is performed by the <a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#RecoSortFilter">RecoSortFilter</a>.</p>
<p>Parameters control the position where zeros are inserted or appended.
 fillingPosition = 0.0 means zeros are inserted at the beginning, 0.5 
means symmetric padding, and 1.0 means appending zeros at the end. 
Arbitrary numbers between 0.0 and 1.0 give the fraction of zeros padded 
at the end (for odd numbers one additional zero is appended at the end).
 Alternatively, the absolute position of the data can be given, using 
the parameter dataPosition.</p>
<p>The size of the output data equals the size of the input data 
multiplied by the floating point value fillingFactor and rounded to the 
closest integer value.</p>
<p>If a fixed output size (parameter fixedSize) is given, the fillingFactor is ignored.</p>
<p><b> Parameters: </b><br>
 </p><table class="doxtable">
<tbody><tr>
<th>Name</th><th>Description</th><th>Type</th><th>Unit </th><th>Values</th><th>Required</th><th>Default </th></tr>
<tr>
<td>fillingFactor </td><td>Size of output relative to the size of the input, rounded to the closest integer </td><td>double </td><td>none </td><td>&gt;= 1.0 </td><td>no </td><td>1.0 </td></tr>
<tr>
<td>fillingPosition </td><td>Relative positioning of filling area: 0 at start, 0.5 symmetric, 1.0 at end </td><td>double </td><td>none </td><td>0.0 &lt;= fillingPosition &lt;= 1.0 </td><td>no </td><td>1.0 </td></tr>
<tr>
<td>dataPosition </td><td>Absolute positioning of the input data within output data range </td><td>int </td><td>none </td><td>0 &lt;= dataPosition &lt;= outSize - inSize </td><td>no </td><td>0 </td></tr>
<tr>
<td>fixedSize </td><td>Absolute output size for resulting data, is ignored if equals zero </td><td>int </td><td>none </td><td>&gt;=0 </td><td>no </td><td>0 </td></tr>
<tr>
<td>powerOfTwo </td><td>Set output size to smallest power of two that is larger or equal to the input size. Is ignored, if fillingFactor &gt; 1.0 </td><td>bool </td><td>none </td><td>true/false </td><td>no </td><td>true  </td></tr>
</tbody></table>
<p><b> Data Structure Translation: </b><br>
 The resulting data stream usually will change its size in the first direction.</p>
<p><b> Technical Details: </b><br>
 This filter does not operate inplace.</p>
<p><b> Example: </b><br>
 </p><pre class="fragment">{     // symmetric filling doubling the size
      RecoDummySource Q{dim=1;sizes={10};baseField=REAL;};
      RecoDummySink S;
      RecoZfillFilter Z{powerOfTwo=false; fillingFactor=2; fillingPosition=0.5};
      Q-&gt;Z-&gt;S;
}
// result:
// 0 1 2 3 4 5 6 7 8 9
// 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 0 0 0 0 0 </pre><p><br>
 <br>
<a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/RecoPublicStages.html#Overview">-&gt; Overview</a> </p><hr>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/index.html">Method Programming Interfaces</a></li><li class="navelem"><a class="el" href="file:///C:/Users/thanh/Desktop/Bruker%20Documentation/Paravision/html%203.5/developer/Topics.html">Topics</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="ParaVision%20360%20V3.5_%20Reconstruction%20Stages_fichiers/doxygen.png" alt="doxygen"></a> 1.8.11 </li>
  </ul>
</div>


</body></html>